<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline' vscode-resource:; script-src 'unsafe-inline' vscode-resource:; img-src vscode-resource: data:; font-src vscode-resource:">
    <title>VSS Drawing Canvas</title>
    
    <!-- Load core initialization systems in proper order -->
    <script src="stylesheet-loader.js"></script>
    <script src="css-initialization.js"></script>
    <script src="script-loading-coordinator.js"></script>
    <script src="resource-uri-builder.js"></script>
    <script src="vscode-api-manager.js"></script>
    
    <!-- Load centralized initialization manager -->
    <script src="initialization-manager.js"></script>
</head>
<body>
    <div id="loading-screen" class="loading-screen">
        <div class="loading-spinner">
            <div class="spinner"></div>
        </div>
        <div class="loading-text">
            <h3>Loading Drawing Canvas...</h3>
            <p id="loading-status">Initializing components...</p>
        </div>
    </div>
    
    <div id="error-screen" class="error-screen" style="display: none;">
        <div class="error-content">
            <h2>‚ö†Ô∏è Canvas Error</h2>
            <div id="error-message" class="error-message"></div>
            <div class="error-actions">
                <button id="retry-button" class="retry-button">Retry</button>
                <button id="report-button" class="report-button">Report Issue</button>
            </div>
            <details class="error-details">
                <summary>Technical Details</summary>
                <pre id="error-stack"></pre>
            </details>
        </div>
    </div>
    
    <div id="canvas-container">
        <div id="status">
            <span>VSS Drawing Canvas - Ready</span>
            <span class="connection-status disconnected" id="connection-status">Disconnected</span>
        </div>
        
        <div class="toolbar">
            <button class="tool-button active" data-tool="pen" id="pen-tool">‚úèÔ∏è Pen</button>
            <button class="tool-button" data-tool="rectangle" id="rectangle-tool">‚¨ú Rectangle</button>
            <button class="tool-button" data-tool="circle" id="circle-tool">‚≠ï Circle</button>
            <button class="tool-button" data-tool="line" id="line-tool">üìè Line</button>
            <button class="tool-button" data-tool="eraser" id="eraser-tool">üßΩ Eraser</button>
            <button class="tool-button" id="clear-canvas">üóëÔ∏è Clear</button>
            <button class="tool-button" id="generate-code">üíª Generate Code</button>
            <button class="tool-button" id="settings-toggle">‚öôÔ∏è Settings</button>
        </div>
        
        <!-- Settings Panel -->
        <div id="settings-panel" style="display: none; position: absolute; top: 100px; left: 10px; width: 250px; background: rgba(30, 30, 30, 0.95); border: 1px solid #555; border-radius: 8px; padding: 15px; z-index: 150;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0; color: #cccccc; font-size: 16px;">Drawing Settings</h3>
                <button id="close-settings" style="background: none; border: none; color: #999; cursor: pointer; font-size: 16px;">‚úï</button>
            </div>
            
            <!-- Stroke Size -->
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Stroke Size: <span id="stroke-size-value">5</span>px</label>
                <input type="range" id="stroke-size" min="1" max="50" value="5" style="width: 100%; background: #3c3c3c;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: #999; margin-top: 2px;">
                    <span>1px</span>
                    <span>50px</span>
                </div>
            </div>
            
            <!-- Opacity -->
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Opacity: <span id="opacity-value">100</span>%</label>
                <input type="range" id="opacity" min="10" max="100" value="100" style="width: 100%; background: #3c3c3c;">
            </div>
            
            <!-- Color Picker -->
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Color</label>
                <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                    <input type="color" id="color-picker" value="#000000" style="width: 40px; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                    <button class="color-preset" data-color="#000000" style="width: 25px; height: 25px; background: #000000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#ff0000" style="width: 25px; height: 25px; background: #ff0000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#00ff00" style="width: 25px; height: 25px; background: #00ff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#0000ff" style="width: 25px; height: 25px; background: #0000ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#ffff00" style="width: 25px; height: 25px; background: #ffff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#ff00ff" style="width: 25px; height: 25px; background: #ff00ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#00ffff" style="width: 25px; height: 25px; background: #00ffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#ffffff" style="width: 25px; height: 25px; background: #ffffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                </div>
            </div>
            
            <!-- Pressure Sensitivity -->
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; color: #cccccc; font-size: 12px; margin-bottom: 8px;">
                    <input type="checkbox" id="pressure-sensitivity" checked style="margin-right: 8px;">
                    Enable Pressure Sensitivity
                </label>
                
                <!-- Pressure Range Controls -->
                <div id="pressure-range-controls" style="margin-left: 20px;">
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; color: #cccccc; font-size: 11px; margin-bottom: 4px;">Min Pressure: <span id="min-pressure-value">10</span>%</label>
                        <input type="range" id="min-pressure" min="1" max="50" value="10" style="width: 100%; background: #3c3c3c;">
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; color: #cccccc; font-size: 11px; margin-bottom: 4px;">Max Pressure: <span id="max-pressure-value">100</span>%</label>
                        <input type="range" id="max-pressure" min="50" max="100" value="100" style="width: 100%; background: #3c3c3c;">
                    </div>
                    
                    <!-- Mouse Speed Simulation -->
                    <div style="margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; color: #cccccc; font-size: 11px; margin-bottom: 4px;">
                            <input type="checkbox" id="mouse-speed-pressure" checked style="margin-right: 6px;">
                            Mouse Speed Simulation
                        </label>
                        <div style="font-size: 9px; color: #999;">Simulate pressure based on drawing speed</div>
                    </div>
                    
                    <!-- Real-time Feedback -->
                    <div style="margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; color: #cccccc; font-size: 11px;">
                            <input type="checkbox" id="pressure-feedback" checked style="margin-right: 6px;">
                            Real-time Feedback
                        </label>
                        <div style="font-size: 9px; color: #999;">Show pressure indicator and cursor</div>
                    </div>
                </div>
                
                <div style="font-size: 10px; color: #999; margin-top: 6px;">Works with pressure-sensitive stylus/tablet</div>
            </div>
            
            <!-- Smoothing -->
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Smoothing: <span id="smoothing-value">50</span>%</label>
                <input type="range" id="smoothing" min="0" max="100" value="50" style="width: 100%; background: #3c3c3c;">
            </div>
            
            <!-- Shape Fill Mode -->
            <div id="shape-fill-mode" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 8px;">Fill Mode</label>
                <div style="display: flex; gap: 5px;">
                    <button id="fill-outline" class="fill-mode-btn active" data-mode="outline" style="flex: 1; padding: 6px; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Outline</button>
                    <button id="fill-filled" class="fill-mode-btn" data-mode="filled" style="flex: 1; padding: 6px; background: #3c3c3c; color: #cccccc; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Filled</button>
                    <button id="fill-both" class="fill-mode-btn" data-mode="both" style="flex: 1; padding: 6px; background: #3c3c3c; color: #cccccc; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Both</button>
                </div>
            </div>
            
            <!-- Stroke Color (for shapes) -->
            <div id="stroke-color-section" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Stroke Color</label>
                <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                    <input type="color" id="stroke-color-picker" value="#000000" style="width: 40px; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                    <button class="stroke-color-preset" data-color="#000000" style="width: 25px; height: 25px; background: #000000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#ff0000" style="width: 25px; height: 25px; background: #ff0000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#00ff00" style="width: 25px; height: 25px; background: #00ff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#0000ff" style="width: 25px; height: 25px; background: #0000ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#ffff00" style="width: 25px; height: 25px; background: #ffff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#ff00ff" style="width: 25px; height: 25px; background: #ff00ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#00ffff" style="width: 25px; height: 25px; background: #00ffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#ffffff" style="width: 25px; height: 25px; background: #ffffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                </div>
            </div>
            
            <!-- Fill Color (shown when fill mode is not outline) -->
            <div id="fill-color-section" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Fill Color</label>
                <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                    <input type="color" id="fill-color-picker" value="#000000" style="width: 40px; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                    <button class="fill-color-preset" data-color="#000000" style="width: 25px; height: 25px; background: #000000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#ff0000" style="width: 25px; height: 25px; background: #ff0000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#00ff00" style="width: 25px; height: 25px; background: #00ff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#0000ff" style="width: 25px; height: 25px; background: #0000ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#ffff00" style="width: 25px; height: 25px; background: #ffff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#ff00ff" style="width: 25px; height: 25px; background: #ff00ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#00ffff" style="width: 25px; height: 25px; background: #00ffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#ffffff" style="width: 25px; height: 25px; background: #ffffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                </div>
            </div>
            
            <!-- Corner Radius (for rectangles) -->
            <div id="corner-radius-section" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Corner Radius: <span id="corner-radius-value">0</span>px</label>
                <input type="range" id="corner-radius" min="0" max="50" value="0" style="width: 100%; background: #3c3c3c;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: #999; margin-top: 2px;">
                    <span>0px</span>
                    <span>50px</span>
                </div>
            </div>
            
            <!-- Ellipse Aspect Ratio (for circles/ellipses) -->
            <div id="ellipse-aspect-section" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 8px;">Ellipse Mode</label>
                <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                    <button id="ellipse-circle" class="ellipse-mode-btn active" data-mode="circle" style="flex: 1; padding: 6px; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Circle</button>
                    <button id="ellipse-free" class="ellipse-mode-btn" data-mode="free" style="flex: 1; padding: 6px; background: #3c3c3c; color: #cccccc; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Free Ellipse</button>
                </div>
                <div id="aspect-ratio-controls" style="display: none;">
                    <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Aspect Ratio: <span id="aspect-ratio-value">1.0</span></label>
                    <input type="range" id="aspect-ratio" min="0.2" max="5.0" step="0.1" value="1.0" style="width: 100%; background: #3c3c3c;">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #999; margin-top: 2px;">
                        <span>0.2 (tall)</span>
                        <span>5.0 (wide)</span>
                    </div>
                </div>
            </div>
        </div>
        
        <canvas id="drawing-canvas"></canvas>
        
        <!-- Pressure Sensitivity Indicator -->
        <div id="pressure-indicator" style="display: none; position: absolute; bottom: 20px; left: 20px; width: 200px; background: rgba(30, 30, 30, 0.9); border: 1px solid #555; border-radius: 6px; padding: 10px; z-index: 200;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #cccccc; font-size: 12px; font-weight: 500;">Pressure</span>
                <span id="pressure-value" style="color: #cccccc; font-size: 12px;">50%</span>
            </div>
            <div style="width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden;">
                <div class="pressure-bar" style="height: 100%; width: 50%; background: #28a745; transition: width 0.1s ease, background-color 0.1s ease;"></div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px;">
                <span class="device-label" style="color: #999; font-size: 10px;">Mouse (Speed)</span>
                <span style="color: #999; font-size: 10px;">Real-time</span>
            </div>
        </div>
        
        <!-- Code Generation Panel -->
        <div id="code-panel" style="display: none; position: absolute; right: 10px; top: 50px; width: 300px; max-height: 400px; background: rgba(30, 30, 30, 0.95); border: 1px solid #555; border-radius: 8px; padding: 10px; z-index: 200;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; color: #cccccc; font-size: 14px;">Generated Code</h3>
                <button id="close-code-panel" style="background: none; border: none; color: #999; cursor: pointer; font-size: 16px;">‚úï</button>
            </div>
            <select id="code-language" style="width: 100%; margin-bottom: 10px; background: #3c3c3c; color: #cccccc; border: 1px solid #555; padding: 5px;">
                <option value="html">HTML Canvas</option>
                <option value="svg">SVG</option>
                <option value="css">CSS</option>
                <option value="javascript">JavaScript</option>
            </select>
            <textarea id="code-output" readonly style="width: 100%; height: 250px; background: #1a1a1a; color: #cccccc; border: 1px solid #555; padding: 8px; font-family: 'Courier New', monospace; font-size: 12px; resize: vertical;"></textarea>
            <div style="margin-top: 10px;">
                <button id="copy-code" style="background: #007acc; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">Copy Code</button>
                <button id="refresh-code" style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-left: 5px;">Refresh</button>
            </div>
        </div>
    </div>

    <!-- Centralized initialization system -->
    <script>
        // The InitializationManager handles all webview startup automatically
        // It will manage API acquisition, resource loading, script coordination, and error recovery
        console.log('Webview initialization delegated to InitializationManager');
    </script>
    


            
            window.VSSCanvas.errorScreen = document.getElementById('error-screen');
            if (!window.VSSCanvas.errorScreen) {
                console.warn('VSSCanvas: Error screen element not found');
            }
            
            window.VSSCanvas.loadingStatus = document.getElementById('loading-status');
            if (!window.VSSCanvas.loadingStatus) {
                console.warn('VSSCanvas: Loading status element not found');
            }
            
            console.log('VSSCanvas: DOM references initialized');
        }
        
        // Initialize DOM references
        initializeDOMReferences();
        
        // Enhanced Drawing Tools Implementation
        window.VSSCanvas.tools = {
            pen: {
                start: function(x, y, pressure = 0.5) {
                    window.VSSCanvas.ctx.beginPath();
                    window.VSSCanvas.ctx.moveTo(x, y);
                    window.VSSCanvas.ctx.lineCap = 'round';
                    window.VSSCanvas.ctx.lineJoin = 'round';
                    
                    // Apply settings
                    const baseSize = window.VSSCanvas.settings.strokeSize;
                    const pressureMultiplier = window.VSSCanvas.settings.pressureSensitivity ? 
                        (pressure * 0.8 + 0.2) : 1.0; // 20% minimum, 100% maximum
                    
                    window.VSSCanvas.ctx.lineWidth = baseSize * pressureMultiplier;
                    window.VSSCanvas.ctx.strokeStyle = window.VSSCanvas.settings.color;
                    window.VSSCanvas.ctx.globalAlpha = window.VSSCanvas.settings.opacity;
                    
                    // Initialize smoothing
                    window.VSSCanvas.smoothedPath = [{x, y, pressure}];
                },
                draw: function(x, y, pressure = 0.5) {
                    if (window.VSSCanvas.settings.smoothing > 0) {
                        // Add point to smoothed path
                        window.VSSCanvas.smoothedPath.push({x, y, pressure});
                        
                        // Apply smoothing
                        if (window.VSSCanvas.smoothedPath.length >= 3) {
                            const smoothed = applySmoothingFilter(window.VSSCanvas.smoothedPath);
                            drawSmoothLine(smoothed);
                        }
                    } else {
                        // Direct drawing without smoothing
                        const baseSize = window.VSSCanvas.settings.strokeSize;
                        const pressureMultiplier = window.VSSCanvas.settings.pressureSensitivity ? 
                            (pressure * 0.8 + 0.2) : 1.0;
                        
                        window.VSSCanvas.ctx.lineWidth = baseSize * pressureMultiplier;
                        window.VSSCanvas.ctx.lineTo(x, y);
                        window.VSSCanvas.ctx.stroke();
                    }
                },
                end: function() {
                    window.VSSCanvas.ctx.globalAlpha = 1.0;
                    window.VSSCanvas.drawingElements.push({
                        type: 'freehand',
                        tool: 'pen',
                        color: window.VSSCanvas.settings.color,
                        width: window.VSSCanvas.settings.strokeSize,
                        opacity: window.VSSCanvas.settings.opacity,
                        timestamp: Date.now()
                    });
                    window.VSSCanvas.smoothedPath = [];
                }
            },
            
            rectangle: {
                start: function(x, y) {
                    window.VSSCanvas.startX = x;
                    window.VSSCanvas.startY = y;
                    window.VSSCanvas.isDrawingShape = true;
                },
                draw: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    // Clear and redraw
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                    
                    // Draw preview rectangle
                    window.VSSCanvas.ctx.strokeStyle = '#007acc';
                    window.VSSCanvas.ctx.lineWidth = 2;
                    window.VSSCanvas.ctx.strokeRect(
                        window.VSSCanvas.startX, 
                        window.VSSCanvas.startY, 
                        x - window.VSSCanvas.startX, 
                        y - window.VSSCanvas.startY
                    );
                },
                end: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    const rect = {
                        type: 'rectangle',
                        x: Math.min(window.VSSCanvas.startX, x),
                        y: Math.min(window.VSSCanvas.startY, y),
                        width: Math.abs(x - window.VSSCanvas.startX),
                        height: Math.abs(y - window.VSSCanvas.startY),
                        color: '#007acc',
                        lineWidth: 2,
                        timestamp: Date.now()
                    };
                    
                    window.VSSCanvas.drawingElements.push(rect);
                    window.VSSCanvas.isDrawingShape = false;
                    
                    // Redraw everything
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                }
            },
            
            circle: {
                start: function(x, y) {
                    window.VSSCanvas.startX = x;
                    window.VSSCanvas.startY = y;
                    window.VSSCanvas.isDrawingShape = true;
                },
                draw: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    const radius = Math.sqrt(Math.pow(x - window.VSSCanvas.startX, 2) + Math.pow(y - window.VSSCanvas.startY, 2));
                    
                    // Clear and redraw
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                    
                    // Draw preview circle
                    window.VSSCanvas.ctx.strokeStyle = '#28a745';
    <!-- 
    All VSSCanvas initialization and drawing functionality has been moved to external scripts
    that are loaded and managed by the InitializationManager. This provides better error
    handling, proper dependency management, and cleaner separation of concerns.
    -->
            window.VSSCanvas.ctx.lineWidth = 2;
            
            console.log('VSSCanvas: Canvas initialization completed');
            updateStatus('Canvas ready for drawing');
        }
        
        function resizeCanvas() {
            if (!window.VSSCanvas.canvas) {
                console.warn('VSSCanvas: Cannot resize canvas - canvas not initialized');
                return;
            }
            
            const container = document.getElementById('canvas-container');
            if (!container) {
                console.warn('VSSCanvas: Cannot resize canvas - container element not found');
                return;
            }
            
            const statusElement = document.getElementById('status');
            const statusHeight = statusElement ? statusElement.offsetHeight : 0;
            
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight - statusHeight;
            
            // Ensure we have valid dimensions (avoid 0x0 canvas)
            const finalWidth = Math.max(newWidth, 300);
            const finalHeight = Math.max(newHeight, 200);
            
            // Get device pixel ratio for high DPI displays
            const dpr = window.devicePixelRatio || 1;
            
            // Only resize if dimensions have changed to avoid unnecessary redraws
            if (window.VSSCanvas.canvas.width !== finalWidth * dpr || window.VSSCanvas.canvas.height !== finalHeight * dpr) {
                console.log(`VSSCanvas: Resizing canvas from ${window.VSSCanvas.canvas.width}x${window.VSSCanvas.canvas.height} to ${finalWidth * dpr}x${finalHeight * dpr} (container: ${newWidth}x${newHeight}, DPR: ${dpr})`);
                
                // Set actual canvas size in memory (scaled for high DPI)
                window.VSSCanvas.canvas.width = finalWidth * dpr;
                window.VSSCanvas.canvas.height = finalHeight * dpr;
                
                // Set display size (CSS pixels)
                window.VSSCanvas.canvas.style.width = finalWidth + 'px';
                window.VSSCanvas.canvas.style.height = finalHeight + 'px';
                
                // Scale the drawing context to match device pixel ratio
                window.VSSCanvas.ctx.scale(dpr, dpr);
                
                // Restore drawing properties after resize (they get reset when canvas dimensions change)
                if (window.VSSCanvas.ctx) {
                    window.VSSCanvas.ctx.lineCap = 'round';
                    window.VSSCanvas.ctx.lineJoin = 'round';
                    window.VSSCanvas.ctx.strokeStyle = '#000000';
                    window.VSSCanvas.ctx.lineWidth = 2;
                }
            }
        }
        
        function setupEventListeners() {
            console.log('VSSCanvas: Setting up event listeners...');
            
            // Window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Tool buttons with existence check
            const toolButtons = document.querySelectorAll('.tool-button[data-tool]');
            if (toolButtons.length > 0) {
                toolButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        selectTool(this.dataset.tool);
                    });
                });
                console.log(`VSSCanvas: Added event listeners to ${toolButtons.length} tool buttons`);
            } else {
                console.warn('VSSCanvas: No tool buttons found');
            }
            
            // Clear canvas button with existence check
            const clearButton = document.getElementById('clear-canvas');
            if (clearButton) {
                clearButton.addEventListener('click', clearCanvas);
                console.log('VSSCanvas: Added event listener to clear button');
            } else {
                console.warn('VSSCanvas: Clear canvas button not found');
            }
            
            // Canvas drawing events with existence check
            if (window.VSSCanvas.canvas) {
                // Mouse events for drawing
                window.VSSCanvas.canvas.addEventListener('mousedown', startDrawing);
                window.VSSCanvas.canvas.addEventListener('mousemove', draw);
                window.VSSCanvas.canvas.addEventListener('mouseup', stopDrawing);
                window.VSSCanvas.canvas.addEventListener('mouseout', stopDrawing);
                
                // Touch events for mobile/tablet support
                window.VSSCanvas.canvas.addEventListener('touchstart', handleTouch);
                window.VSSCanvas.canvas.addEventListener('touchmove', handleTouch);
                window.VSSCanvas.canvas.addEventListener('touchend', stopDrawing);
                
                console.log('VSSCanvas: Added drawing event listeners to canvas');
            } else {
                console.error('VSSCanvas: Cannot add drawing event listeners - canvas not initialized');
                throw new Error('Canvas not initialized before setting up event listeners');
            }
            
            // Settings panel event listeners
            const settingsToggle = document.getElementById('settings-toggle');
            const settingsPanel = document.getElementById('settings-panel');
            const closeSettings = document.getElementById('close-settings');
            
            if (settingsToggle && settingsPanel) {
                settingsToggle.addEventListener('click', function() {
                    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
                });
            }
            
            if (closeSettings && settingsPanel) {
                closeSettings.addEventListener('click', function() {
                    settingsPanel.style.display = 'none';
                });
            }
            
            // Stroke size control
            const strokeSizeSlider = document.getElementById('stroke-size');
            const strokeSizeValue = document.getElementById('stroke-size-value');
            if (strokeSizeSlider && strokeSizeValue) {
                strokeSizeSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.strokeSize = parseInt(this.value);
                    strokeSizeValue.textContent = this.value;
                });
            }
            
            // Opacity control
            const opacitySlider = document.getElementById('opacity');
            const opacityValue = document.getElementById('opacity-value');
            if (opacitySlider && opacityValue) {
                opacitySlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.opacity = parseInt(this.value) / 100;
                    opacityValue.textContent = this.value;
                });
            }
            
            // Color picker
            const colorPicker = document.getElementById('color-picker');
            if (colorPicker) {
                colorPicker.addEventListener('change', function() {
                    window.VSSCanvas.settings.color = this.value;
                });
            }
            
            // Color presets
            const colorPresets = document.querySelectorAll('.color-preset');
            colorPresets.forEach(preset => {
                preset.addEventListener('click', function() {
                    const color = this.dataset.color;
                    window.VSSCanvas.settings.color = color;
                    if (colorPicker) colorPicker.value = color;
                });
            });
            
            // Pressure sensitivity toggle
            const pressureSensitivity = document.getElementById('pressure-sensitivity');
            if (pressureSensitivity) {
                pressureSensitivity.addEventListener('change', function() {
                    window.VSSCanvas.settings.pressureSensitivity = this.checked;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setEnabled(this.checked);
                    }
                    
                    // Show/hide pressure range controls
                    const pressureRangeControls = document.getElementById('pressure-range-controls');
                    if (pressureRangeControls) {
                        pressureRangeControls.style.display = this.checked ? 'block' : 'none';
                    }
                });
            }
            
            // Min pressure control
            const minPressureSlider = document.getElementById('min-pressure');
            const minPressureValue = document.getElementById('min-pressure-value');
            if (minPressureSlider && minPressureValue) {
                minPressureSlider.addEventListener('input', function() {
                    const minValue = parseInt(this.value);
                    window.VSSCanvas.settings.minPressure = minValue / 100;
                    minPressureValue.textContent = minValue;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setPressureRange(
                            window.VSSCanvas.settings.minPressure,
                            window.VSSCanvas.settings.maxPressure
                        );
                    }
                    
                    // Ensure min doesn't exceed max
                    const maxPressureSlider = document.getElementById('max-pressure');
                    if (maxPressureSlider && minValue >= parseInt(maxPressureSlider.value)) {
                        maxPressureSlider.value = minValue + 10;
                        const maxPressureValue = document.getElementById('max-pressure-value');
                        if (maxPressureValue) {
                            maxPressureValue.textContent = maxPressureSlider.value;
                            window.VSSCanvas.settings.maxPressure = parseInt(maxPressureSlider.value) / 100;
                        }
                    }
                });
            }
            
            // Max pressure control
            const maxPressureSlider = document.getElementById('max-pressure');
            const maxPressureValue = document.getElementById('max-pressure-value');
            if (maxPressureSlider && maxPressureValue) {
                maxPressureSlider.addEventListener('input', function() {
                    const maxValue = parseInt(this.value);
                    window.VSSCanvas.settings.maxPressure = maxValue / 100;
                    maxPressureValue.textContent = maxValue;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setPressureRange(
                            window.VSSCanvas.settings.minPressure,
                            window.VSSCanvas.settings.maxPressure
                        );
                    }
                    
                    // Ensure max doesn't go below min
                    const minPressureSlider = document.getElementById('min-pressure');
                    if (minPressureSlider && maxValue <= parseInt(minPressureSlider.value)) {
                        minPressureSlider.value = maxValue - 10;
                        const minPressureValue = document.getElementById('min-pressure-value');
                        if (minPressureValue) {
                            minPressureValue.textContent = minPressureSlider.value;
                            window.VSSCanvas.settings.minPressure = parseInt(minPressureSlider.value) / 100;
                        }
                    }
                });
            }
            
            // Mouse speed pressure toggle
            const mouseSpeedPressure = document.getElementById('mouse-speed-pressure');
            if (mouseSpeedPressure) {
                mouseSpeedPressure.addEventListener('change', function() {
                    window.VSSCanvas.settings.mouseSpeedPressure = this.checked;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setMouseSpeedPressure(this.checked);
                    }
                });
            }
            
            // Pressure feedback toggle
            const pressureFeedback = document.getElementById('pressure-feedback');
            if (pressureFeedback) {
                pressureFeedback.addEventListener('change', function() {
                    window.VSSCanvas.settings.pressureFeedback = this.checked;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setFeedbackEnabled(this.checked);
                    }
                });
            }
            
            // Initialize pressure controls visibility and values
            function initializePressureControls() {
                // Set initial visibility of pressure range controls
                const pressureRangeControls = document.getElementById('pressure-range-controls');
                const pressureSensitivityCheckbox = document.getElementById('pressure-sensitivity');
                
                if (pressureRangeControls && pressureSensitivityCheckbox) {
                    pressureRangeControls.style.display = pressureSensitivityCheckbox.checked ? 'block' : 'none';
                }
                
                // Set initial values from settings
                if (minPressureSlider && minPressureValue) {
                    minPressureSlider.value = window.VSSCanvas.settings.minPressure * 100;
                    minPressureValue.textContent = Math.round(window.VSSCanvas.settings.minPressure * 100);
                }
                
                if (maxPressureSlider && maxPressureValue) {
                    maxPressureSlider.value = window.VSSCanvas.settings.maxPressure * 100;
                    maxPressureValue.textContent = Math.round(window.VSSCanvas.settings.maxPressure * 100);
                }
                
                if (mouseSpeedPressure) {
                    mouseSpeedPressure.checked = window.VSSCanvas.settings.mouseSpeedPressure;
                }
                
                if (pressureFeedback) {
                    pressureFeedback.checked = window.VSSCanvas.settings.pressureFeedback;
                }
                
                console.log('Pressure controls initialized');
            }
            
            // Call initialization
            initializePressureControls();
            
            // Smoothing control
            const smoothingSlider = document.getElementById('smoothing');
            const smoothingValue = document.getElementById('smoothing-value');
            if (smoothingSlider && smoothingValue) {
                smoothingSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.smoothing = parseInt(this.value);
                    smoothingValue.textContent = this.value;
                });
            }
            
            // Fill mode buttons
            const fillModeButtons = document.querySelectorAll('.fill-mode-btn');
            fillModeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Update active state
                    fillModeButtons.forEach(btn => {
                        btn.classList.remove('active');
                        btn.style.background = '#3c3c3c';
                        btn.style.color = '#cccccc';
                    });
                    this.classList.add('active');
                    this.style.background = '#007acc';
                    this.style.color = 'white';
                    
                    // Update setting
                    window.VSSCanvas.settings.fillMode = this.dataset.mode;
                    
                    // Show/hide fill color section
                    const fillColorSection = document.getElementById('fill-color-section');
                    if (fillColorSection) {
                        fillColorSection.style.display = 
                            (this.dataset.mode === 'outline') ? 'none' : 'block';
                    }
                });
            });
            
            // Fill color picker
            const fillColorPicker = document.getElementById('fill-color-picker');
            if (fillColorPicker) {
                fillColorPicker.addEventListener('change', function() {
                    window.VSSCanvas.settings.fillColor = this.value;
                });
            }
            
            // Fill color presets
            const fillColorPresets = document.querySelectorAll('.fill-color-preset');
            fillColorPresets.forEach(preset => {
                preset.addEventListener('click', function() {
                    const color = this.dataset.color;
                    window.VSSCanvas.settings.fillColor = color;
                    if (fillColorPicker) fillColorPicker.value = color;
                });
            });
            
            // Corner radius control
            const cornerRadiusSlider = document.getElementById('corner-radius');
            const cornerRadiusValue = document.getElementById('corner-radius-value');
            if (cornerRadiusSlider && cornerRadiusValue) {
                cornerRadiusSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.cornerRadius = parseInt(this.value);
                    cornerRadiusValue.textContent = this.value;
                });
            }
            
            // Ellipse mode buttons
            const ellipseModeButtons = document.querySelectorAll('.ellipse-mode-btn');
            ellipseModeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Update active state
                    ellipseModeButtons.forEach(btn => {
                        btn.classList.remove('active');
                        btn.style.background = '#3c3c3c';
                        btn.style.color = '#cccccc';
                    });
                    this.classList.add('active');
                    this.style.background = '#007acc';
                    this.style.color = 'white';
                    
                    // Update setting
                    window.VSSCanvas.settings.ellipseMode = this.dataset.mode;
                    
                    // Show/hide aspect ratio controls
                    const aspectRatioControls = document.getElementById('aspect-ratio-controls');
                    if (aspectRatioControls) {
                        aspectRatioControls.style.display = 
                            (this.dataset.mode === 'free') ? 'block' : 'none';
                    }
                });
            });
            
            // Aspect ratio control
            const aspectRatioSlider = document.getElementById('aspect-ratio');
            const aspectRatioValue = document.getElementById('aspect-ratio-value');
            if (aspectRatioSlider && aspectRatioValue) {
                aspectRatioSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.aspectRatio = parseFloat(this.value);
                    aspectRatioValue.textContent = parseFloat(this.value).toFixed(1);
                });
            }
            
            // Generate code button
            const generateCodeBtn = document.getElementById('generate-code');
            const codePanel = document.getElementById('code-panel');
            if (generateCodeBtn && codePanel) {
                generateCodeBtn.addEventListener('click', function() {
                    generateCode();
                    codePanel.style.display = codePanel.style.display === 'none' ? 'block' : 'none';
                });
            }
            
            // Close code panel
            const closeCodePanel = document.getElementById('close-code-panel');
            if (closeCodePanel && codePanel) {
                closeCodePanel.addEventListener('click', function() {
                    codePanel.style.display = 'none';
                });
            }
            
            // Copy code functionality
            const copyCodeBtn = document.getElementById('copy-code');
            const refreshCodeBtn = document.getElementById('refresh-code');
            const codeOutput = document.getElementById('code-output');
            
            if (copyCodeBtn && codeOutput) {
                copyCodeBtn.addEventListener('click', function() {
                    codeOutput.select();
                    document.execCommand('copy');
                    
                    // Visual feedback
                    const originalText = this.textContent;
                    this.textContent = 'Copied!';
                    this.style.background = '#28a745';
                    
                    setTimeout(() => {
                        this.textContent = originalText;
                        this.style.background = '#007acc';
                    }, 1000);
                });
            }
            
            if (refreshCodeBtn) {
                refreshCodeBtn.addEventListener('click', function() {
                    generateCode();
                });
            }
            
            // Language selector change
            const languageSelector = document.getElementById('code-language');
            if (languageSelector) {
                languageSelector.addEventListener('change', function() {
                    generateCode();
                });
            }
            
            console.log('VSSCanvas: Event listeners setup completed');
        }
        
        function setupMessagePassing() {
            // Listen for messages from VS Code extension
            window.addEventListener('message', event => {
                const message = event.data;
                
                switch (message.command) {
                    case 'clearCanvas':
                        clearCanvas();
                        break;
                    case 'setTool':
                        selectTool(message.tool);
                        break;
                    case 'connectionStatus':
                        updateConnectionStatus(message.connected);
                        break;
                    default:
                        console.log('Unknown message:', message);
                }
            });
            
            // Send initial ready message to extension
            sendMessage({
                command: 'canvasReady',
                data: {
                    width: window.VSSCanvas.canvas.width,
                    height: window.VSSCanvas.canvas.height
                }
            });
        }
        
        function sendMessage(message) {
            try {
                // Check if VS Code API is available
                if (!window.VSSCanvas.vscode) {
                    console.warn('VSSCanvas: VS Code API not available, cannot send message:', message);
                    return false;
                }
                
                window.VSSCanvas.vscode.postMessage(message);
                return true;
            } catch (error) {
                console.error('VSSCanvas: Error sending message to extension:', error);
                updateStatus('Communication error with extension');
                
                // If we're not initialized yet, show error screen
                if (!window.VSSCanvas.hasInitialized) {
                    showError('Failed to communicate with VS Code extension: ' + error.message, error.stack);
                }
                return false;
            }
        }
        
        function selectTool(tool) {
            window.VSSCanvas.currentTool = tool;
            
            // Update button states
            document.querySelectorAll('.tool-button[data-tool]').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            // Update cursor
            window.VSSCanvas.canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
            
            // Show/hide shape-specific settings
            updateShapeSettings(tool);
            
            updateStatus(`Selected tool: ${tool}`);
            
            // Notify extension of tool change
            sendMessage({
                command: 'toolChanged',
                data: { tool: tool }
            });
        }
        
        function updateShapeSettings(tool) {
            const shapeFillMode = document.getElementById('shape-fill-mode');
            const fillColorSection = document.getElementById('fill-color-section');
            const cornerRadiusSection = document.getElementById('corner-radius-section');
            const ellipseAspectSection = document.getElementById('ellipse-aspect-section');
            
            // Hide all shape settings by default
            if (shapeFillMode) shapeFillMode.style.display = 'none';
            if (fillColorSection) fillColorSection.style.display = 'none';
            if (cornerRadiusSection) cornerRadiusSection.style.display = 'none';
            if (ellipseAspectSection) ellipseAspectSection.style.display = 'none';
            
            // Show relevant settings for shape tools
            if (tool === 'rectangle' || tool === 'circle' || tool === 'line') {
                if (shapeFillMode) shapeFillMode.style.display = 'block';
                
                // Show fill color if not in outline mode
                if (window.VSSCanvas.settings.fillMode !== 'outline' && fillColorSection) {
                    fillColorSection.style.display = 'block';
                }
                
                // Show corner radius only for rectangles
                if (tool === 'rectangle' && cornerRadiusSection) {
                    cornerRadiusSection.style.display = 'block';
                }
                
                // Show ellipse aspect controls only for circles
                if (tool === 'circle' && ellipseAspectSection) {
                    ellipseAspectSection.style.display = 'block';
                }
            }
        }
        
        function startDrawing(e) {
            window.VSSCanvas.isDrawing = true;
            [window.VSSCanvas.lastX, window.VSSCanvas.lastY] = getMousePos(e);
            
            // Get pressure information
            const pressure = getPressureFromEvent(e);
            
            // Use enhanced tools system
            if (window.VSSCanvas.tools && window.VSSCanvas.tools[window.VSSCanvas.currentTool]) {
                window.VSSCanvas.tools[window.VSSCanvas.currentTool].start(window.VSSCanvas.lastX, window.VSSCanvas.lastY, pressure);
            } else {
                // Fallback to basic drawing
                window.VSSCanvas.ctx.beginPath();
                window.VSSCanvas.ctx.moveTo(window.VSSCanvas.lastX, window.VSSCanvas.lastY);
            }
            
            sendMessage({
                command: 'drawingStarted',
                data: { 
                    tool: window.VSSCanvas.currentTool,
                    x: window.VSSCanvas.lastX, 
                    y: window.VSSCanvas.lastY,
                    pressure: pressure
                }
            });
        }
        
        function draw(e) {
            if (!window.VSSCanvas.isDrawing) return;
            
            const [currentX, currentY] = getMousePos(e);
            const pressure = getPressureFromEvent(e);
            
            // Use enhanced tools system
            if (window.VSSCanvas.tools && window.VSSCanvas.tools[window.VSSCanvas.currentTool]) {
                window.VSSCanvas.tools[window.VSSCanvas.currentTool].draw(currentX, currentY, pressure);
            } else {
                // Fallback to basic drawing
                if (window.VSSCanvas.currentTool === 'pen') {
                    window.VSSCanvas.ctx.globalCompositeOperation = 'source-over';
                    window.VSSCanvas.ctx.strokeStyle = window.VSSCanvas.settings.color;
                    window.VSSCanvas.ctx.lineWidth = window.VSSCanvas.settings.strokeSize;
                } else if (window.VSSCanvas.currentTool === 'eraser') {
                    window.VSSCanvas.ctx.globalCompositeOperation = 'destination-out';
                    window.VSSCanvas.ctx.lineWidth = window.VSSCanvas.settings.strokeSize * 2;
                }
                
                window.VSSCanvas.ctx.lineTo(currentX, currentY);
                window.VSSCanvas.ctx.stroke();
            }
            
            [window.VSSCanvas.lastX, window.VSSCanvas.lastY] = [currentX, currentY];
            
            // Send drawing data to extension (throttled)
            if (Math.random() < 0.1) { // Only send 10% of drawing events to avoid spam
                sendMessage({
                    command: 'drawing',
                    data: {
                        tool: window.VSSCanvas.currentTool,
                        x: currentX,
                        y: currentY,
                        lastX: window.VSSCanvas.lastX,
                        lastY: window.VSSCanvas.lastY
                    }
                });
            }
        }
        
        function stopDrawing() {
            if (!window.VSSCanvas.isDrawing) return;
            
            window.VSSCanvas.isDrawing = false;
            window.VSSCanvas.ctx.beginPath(); // Reset path
            
            sendMessage({
                command: 'drawingEnded',
                data: { tool: window.VSSCanvas.currentTool }
            });
        }
        
        function handleTouch(e) {
            e.preventDefault();
            
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                            e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            
            window.VSSCanvas.canvas.dispatchEvent(mouseEvent);
        }
        
        function getMousePos(e) {
            const rect = window.VSSCanvas.canvas.getBoundingClientRect();
            // No need to scale by DPR here since we're working in CSS pixels
            // The scaling is handled by the context.scale() in resizeCanvas
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }
        
        function clearCanvas() {
            window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
            updateStatus('Canvas cleared');
            
            sendMessage({
                command: 'canvasCleared',
                data: {}
            });
        }
        
        function updateStatus(message) {
            const statusElement = document.getElementById('status');
            const statusText = statusElement.querySelector('span:first-child');
            statusText.textContent = `VSS Drawing Canvas - ${message}`;
        }
        
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connection-status');
            statusElement.textContent = connected ? 'Connected' : 'Disconnected';
            statusElement.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
        }
        
        // Start connection monitoring after initialization
        function startConnectionMonitoring() {
            window.VSSCanvas.connectionCheckInterval = setInterval(function() {
                const timeSinceLastMessage = Date.now() - window.VSSCanvas.lastMessageTime;
                const isConnected = timeSinceLastMessage < 30000; // 30 seconds timeout
                updateConnectionStatus(isConnected);
            }, 5000);
        }

        // Listen for messages from extension to track connection
        window.addEventListener('message', function(event) {
            window.VSSCanvas.lastMessageTime = Date.now();
            updateConnectionStatus(true);
        });

        // Start monitoring once canvas is ready
        setTimeout(function() {
            if (window.VSSCanvas.hasInitialized) {
                startConnectionMonitoring();
            }
        }, 1000);

        // Cleanup on unload
        window.addEventListener('beforeunload', function() {
            if (window.VSSCanvas.connectionCheckInterval) {
                clearInterval(window.VSSCanvas.connectionCheckInterval);
            }
            if (window.VSSCanvas.initializationTimeout) {
                clearTimeout(window.VSSCanvas.initializationTimeout);
            }
        });
        
        // Add methods to the existing VSSCanvas namespace
        window.VSSCanvas.init = function() {
            console.log('VSSCanvas: Starting initialization for instance ID:', this.instanceId);
            
            if (this.initialized) {
                console.log('VSSCanvas: Already initialized, performing cleanup before reinitializing...');
                this.cleanup();
            }
            
            try {
                // Mark initialization start time for debugging
                this.initStartedAt = new Date().toISOString();
                
                updateLoadingStatus('Initializing canvas...');
                initializeCanvas();
                
                updateLoadingStatus('Setting up drawing tools...');
                setupEventListeners();
                
                updateLoadingStatus('Establishing connection...');
                setupMessagePassing();
                
                updateLoadingStatus('Canvas ready!');
                updateStatus('Canvas initialized successfully');
                
                // Mark as initialized
                this.initialized = true;
                this.initCompletedAt = new Date().toISOString();
                
                console.log('VSSCanvas: Initialization completed successfully for instance ID:', this.instanceId);
                
                // Hide loading screen after a short delay
                setTimeout(function() {
                    if (window.VSSCanvas.initializationTimeout) {
                        clearTimeout(window.VSSCanvas.initializationTimeout);
                        window.VSSCanvas.initializationTimeout = null;
                    }
                    hideLoadingScreen();
                }, 500);
                
                return true;
            } catch (error) {
                console.error('VSSCanvas: Initialization failed for instance ID:', this.instanceId, error);
                
                // Clear initialization timeout on error
                if (this.initializationTimeout) {
                    clearTimeout(this.initializationTimeout);
                    this.initializationTimeout = null;
                }
                
                // Mark initialization failure time for debugging
                this.initFailedAt = new Date().toISOString();
                this.lastInitError = error.message;
                
                showError('Initialization failed: ' + error.message, error.stack);
                return false;
            }
        };
        
        // Cleanup method with comprehensive existence checks
        window.VSSCanvas.cleanup = function() {
            console.log('VSSCanvas: Starting cleanup for instance ID:', this.instanceId);
            
            try {
                // Clear timeouts with existence checks
                if (this.initializationTimeout) {
                    console.log('VSSCanvas: Clearing initialization timeout');
                    clearTimeout(this.initializationTimeout);
                    this.initializationTimeout = null;
                }
                
                if (this.connectionCheckInterval) {
                    console.log('VSSCanvas: Clearing connection check interval');
                    clearInterval(this.connectionCheckInterval);
                    this.connectionCheckInterval = null;
                }
                
                // Clear canvas if it exists and is valid
                if (this.ctx && this.canvas) {
                    try {
                        console.log('VSSCanvas: Clearing canvas content');
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    } catch (canvasError) {
                        console.warn('VSSCanvas: Error clearing canvas:', canvasError);
                    }
                }
                
                // Reset state variables
                this.hasInitialized = false;
                this.isDrawing = false;
                this.currentTool = 'pen';
                this.lastX = 0;
                this.lastY = 0;
                
                // Reset DOM references
                this.loadingScreen = null;
                this.errorScreen = null;
                this.loadingStatus = null;
                
                // Reset canvas references
                this.canvas = null;
                this.ctx = null;
                
                // Reset initialization flag
                this.initialized = false;
                
                // Update timestamp for debugging
                this.lastCleanupAt = new Date().toISOString();
                
                console.log('VSSCanvas: Cleanup completed successfully for instance ID:', this.instanceId);
                
            } catch (cleanupError) {
                console.error('VSSCanvas: Error during cleanup:', cleanupError);
                // Continue with cleanup even if some parts fail
                this.initialized = false;
                this.hasInitialized = false;
            }
        };
        
        // Check if canvas is initialized
        window.VSSCanvas.isInitialized = function() {
            return this.initialized && this.hasInitialized;
        };
        
        // Get current canvas state
        window.VSSCanvas.getState = function() {
            return {
                initialized: this.initialized,
                hasInitialized: this.hasInitialized,
                isDrawing: this.isDrawing,
                currentTool: this.currentTool,
                canvasSize: this.canvas ? { width: this.canvas.width, height: this.canvas.height } : null
            };
        };
        
        // Force reinitialization
        window.VSSCanvas.reinitialize = function() {
            this.cleanup();
            return this.init();
        };
        
        // Initialize ResourceURIBuilder for proper vscode-resource URI handling
        // This will be handled by the ScriptLoadingCoordinator when dependencies are ready
        if (window.ScriptLoadingCoordinator) {
            const coordinator = window.ScriptLoadingCoordinator.getInstance();
            
            // Register callback for when all scripts are loaded
            coordinator.onAllScriptsLoaded(() => {
                if (window.ResourceURIBuilder && window.VSCodeAPIManager) {
                    const resourceBuilder = new window.ResourceURIBuilder();
                    
                    // Wait for VS Code API to be ready, then initialize ResourceURIBuilder
                    window.VSCodeAPIManager.onAPIReady(() => {
                        try {
                            const vscodeApi = window.VSCodeAPIManager.getAPI();
                            
                            // Initialize with available context
                            resourceBuilder.initialize(vscodeApi, null, null);
                            
                            // Update all existing resource references to use proper URIs
                            const updateResults = resourceBuilder.updateAllResourceReferences();
                            console.log('Resource URI updates completed:', updateResults);
                            
                            // Make resourceBuilder globally available
                            window.resourceBuilder = resourceBuilder;
                            
                        } catch (error) {
                            console.error('Failed to initialize ResourceURIBuilder:', error);
                        }
                    });
                }
            });
        }
        
        })(); // End of IIFE
    </script>
</body>
</html>