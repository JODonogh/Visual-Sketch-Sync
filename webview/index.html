<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline' vscode-resource:; script-src 'unsafe-inline' vscode-resource:; img-src vscode-resource: data:; font-src vscode-resource:; connect-src vscode-resource:; media-src vscode-resource:; object-src 'none'; base-uri 'none'; form-action 'none'">
    <title>VSS Drawing Canvas</title>
    
    <!-- Load main styles -->
    <link rel="stylesheet" href="main-styles.css">
    
    <!-- Load core initialization systems in proper order -->
    <!-- Scripts will be loaded dynamically with proper vscode-resource URIs -->
    <script>
        // Get the proper vscode-resource base URI
        const getResourceUri = (path) => {
            // Try multiple approaches to get the correct URI
            
            // Approach 1: Use acquireVsCodeApi if available
            if (typeof acquireVsCodeApi === 'function') {
                try {
                    const vscode = acquireVsCodeApi();
                    if (vscode && vscode.asWebviewUri) {
                        // This would be the proper way, but may not be available in all contexts
                        return vscode.asWebviewUri(path).toString();
                    }
                } catch (e) {
                    console.warn('Could not use vscode.asWebviewUri:', e);
                }
            }
            
            // Approach 2: Extract from current URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const baseAuthority = urlParams.get('vscode-resource-base-authority');
            if (baseAuthority) {
                const basePath = window.location.pathname.replace('/index.html', '');
                return `https://${baseAuthority}/file${basePath}/${path}`;
            }
            
            // Approach 3: Use relative path as fallback (may work in some contexts)
            console.warn('Using relative path fallback for:', path);
            return path;
        };

        // Load scripts in proper order with error handling and fallbacks
        const loadScript = (src) => {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                const resourceUri = getResourceUri(src);
                
                console.log(`Loading script: ${src} -> ${resourceUri}`);
                script.src = resourceUri;
                
                script.onload = () => {
                    console.log(`Successfully loaded: ${src}`);
                    resolve();
                };
                
                script.onerror = (error) => {
                    console.error(`Failed to load script: ${src} from ${resourceUri}`, error);
                    
                    // Try fallback with relative path if the resource URI failed
                    if (resourceUri !== src) {
                        console.log(`Trying fallback relative path for: ${src}`);
                        const fallbackScript = document.createElement('script');
                        fallbackScript.src = src;
                        
                        fallbackScript.onload = () => {
                            console.log(`Fallback successful for: ${src}`);
                            resolve();
                        };
                        
                        fallbackScript.onerror = () => {
                            reject(new Error(`Failed to load ${src} (both resource URI and relative path failed)`));
                        };
                        
                        document.head.appendChild(fallbackScript);
                    } else {
                        reject(new Error(`Failed to load ${src}`));
                    }
                };
                
                document.head.appendChild(script);
            });
        };

        // Load all required scripts in sequence
        const loadAllScripts = async () => {
            try {
                console.log('Loading webview scripts with proper vscode-resource URIs...');
                
                // Load core scripts in dependency order
                await loadScript('diagnostic-logger.js');
                await loadScript('vscode-api-manager.js');
                await loadScript('resource-uri-builder.js');
                await loadScript('stylesheet-loader.js');
                await loadScript('css-initialization.js');
                await loadScript('csp-violation-handler.js');
                await loadScript('script-loading-coordinator.js');
                await loadScript('error-recovery-manager.js');
                await loadScript('initialization-manager.js');
                
                console.log('All webview scripts loaded successfully');
                
                // Initialize the webview
                if (window.InitializationManager) {
                    const manager = window.InitializationManager.getInstance();
                    await manager.initialize();
                } else {
                    throw new Error('InitializationManager not available after script loading');
                }
                
            } catch (error) {
                console.error('Failed to load webview scripts:', error);
                
                // Show error screen with detailed information
                const errorScreen = document.getElementById('error-screen');
                const loadingScreen = document.getElementById('loading-screen');
                
                if (errorScreen && loadingScreen) {
                    loadingScreen.style.display = 'none';
                    errorScreen.style.display = 'flex';
                    
                    const errorMessage = document.getElementById('error-message');
                    const errorStack = document.getElementById('error-stack');
                    
                    if (errorMessage) {
                        errorMessage.textContent = `Script loading failed: ${error.message}`;
                    }
                    
                    if (errorStack) {
                        errorStack.textContent = `Error details:\n${error.stack || 'No stack trace available'}\n\nThis may be due to Content Security Policy restrictions or incorrect resource URIs.`;
                    }
                    
                    // Add retry functionality
                    const retryButton = document.getElementById('retry-button');
                    if (retryButton) {
                        retryButton.onclick = () => {
                            errorScreen.style.display = 'none';
                            loadingScreen.style.display = 'flex';
                            setTimeout(loadAllScripts, 1000);
                        };
                    }
                }
            }
        };

        // Start loading when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadAllScripts);
        } else {
            loadAllScripts();
        }
    </script>
</head>
<body>
    <div id="loading-screen" class="loading-screen">
        <div class="loading-spinner">
            <div class="spinner"></div>
        </div>
        <div class="loading-text">
            <h3>Loading Drawing Canvas...</h3>
            <p id="loading-status">Initializing components...</p>
        </div>
    </div>
    
    <div id="error-screen" class="error-screen hidden">
        <div class="error-content">
            <h2>‚ö†Ô∏è Canvas Error</h2>
            <div id="error-message" class="error-message"></div>
            <div class="error-actions">
                <button id="retry-button" class="retry-button">Retry</button>
                <button id="report-button" class="report-button">Report Issue</button>
            </div>
            <details class="error-details">
                <summary>Technical Details</summary>
                <pre id="error-stack"></pre>
            </details>
        </div>
    </div>
    
    <div id="canvas-container">
        <div id="status">
            <span>VSS Drawing Canvas - Ready</span>
            <span class="connection-status disconnected" id="connection-status">Disconnected</span>
        </div>
        
        <div class="toolbar">
            <button class="tool-button active" data-tool="pen" id="pen-tool">‚úèÔ∏è Pen</button>
            <button class="tool-button" data-tool="rectangle" id="rectangle-tool">‚¨ú Rectangle</button>
            <button class="tool-button" data-tool="circle" id="circle-tool">‚≠ï Circle</button>
            <button class="tool-button" data-tool="line" id="line-tool">üìè Line</button>
            <button class="tool-button" data-tool="eraser" id="eraser-tool">üßΩ Eraser</button>
            <button class="tool-button" id="clear-canvas">üóëÔ∏è Clear</button>
            <button class="tool-button" id="generate-code">üíª Generate Code</button>
            <button class="tool-button" id="settings-toggle">‚öôÔ∏è Settings</button>
        </div>
        
        <!-- Settings Panel -->
        <div id="settings-panel" class="settings-panel">
            <div class="settings-header">
                <h3 class="settings-title">Drawing Settings</h3>
                <button id="close-settings" class="close-settings-btn">‚úï</button>
            </div>
            
            <!-- Stroke Size -->
            <div class="setting-group">
                <label class="setting-label">Stroke Size: <span id="stroke-size-value">5</span>px</label>
                <input type="range" id="stroke-size" min="1" max="50" value="5" class="setting-range">
                <div class="range-labels">
                    <span>1px</span>
                    <span>50px</span>
                </div>
            </div>
            
            <!-- Opacity -->
            <div class="setting-group">
                <label class="setting-label">Opacity: <span id="opacity-value">100</span>%</label>
                <input type="range" id="opacity" min="10" max="100" value="100" class="setting-range">
            </div>
            
            <!-- Color Picker -->
            <div class="setting-group">
                <label class="setting-label">Color</label>
                <div class="color-picker-container">
                    <input type="color" id="color-picker" value="#000000" class="color-picker">
                    <button class="color-preset" data-color="#000000"></button>
                    <button class="color-preset" data-color="#ff0000"></button>
                    <button class="color-preset" data-color="#00ff00"></button>
                    <button class="color-preset" data-color="#0000ff"></button>
                    <button class="color-preset" data-color="#ffff00"></button>
                    <button class="color-preset" data-color="#ff00ff"></button>
                    <button class="color-preset" data-color="#00ffff"></button>
                    <button class="color-preset" data-color="#ffffff"></button>
                </div>
            </div>
            
            <!-- Pressure Sensitivity -->
            <div class="setting-group">
                <label class="setting-label-flex">
                    <input type="checkbox" id="pressure-sensitivity" checked class="checkbox-input">
                    Enable Pressure Sensitivity
                </label>
                
                <!-- Pressure Range Controls -->
                <div id="pressure-range-controls" class="pressure-controls">
                    <div class="pressure-control-group">
                        <label class="setting-label-small">Min Pressure: <span id="min-pressure-value">10</span>%</label>
                        <input type="range" id="min-pressure" min="1" max="50" value="10" class="setting-range">
                    </div>
                    
                    <div class="pressure-control-group">
                        <label class="setting-label-small">Max Pressure: <span id="max-pressure-value">100</span>%</label>
                        <input type="range" id="max-pressure" min="50" max="100" value="100" class="setting-range">
                    </div>
                    
                    <!-- Mouse Speed Simulation -->
                    <div class="pressure-control-group">
                        <label class="setting-label-small-flex">
                            <input type="checkbox" id="mouse-speed-pressure" checked class="checkbox-input-small">
                            Mouse Speed Simulation
                        </label>
                        <div class="setting-description">Simulate pressure based on drawing speed</div>
                    </div>
                    
                    <!-- Real-time Feedback -->
                    <div class="pressure-control-group">
                        <label class="setting-label-small-flex">
                            <input type="checkbox" id="pressure-feedback" checked class="checkbox-input-small">
                            Real-time Feedback
                        </label>
                        <div class="setting-description">Show pressure indicator and cursor</div>
                    </div>
                </div>
                
                <div class="setting-note">Works with pressure-sensitive stylus/tablet</div>
            </div>
            
            <!-- Smoothing -->
            <div class="setting-group">
                <label class="setting-label">Smoothing: <span id="smoothing-value">50</span>%</label>
                <input type="range" id="smoothing" min="0" max="100" value="50" class="setting-range">
            </div>
            
            <!-- Shape Fill Mode -->
            <div id="shape-fill-mode" class="setting-group hidden">
                <label class="setting-label">Fill Mode</label>
                <div class="fill-mode-buttons">
                    <button id="fill-outline" class="fill-mode-btn active" data-mode="outline">Outline</button>
                    <button id="fill-filled" class="fill-mode-btn" data-mode="filled">Filled</button>
                    <button id="fill-both" class="fill-mode-btn" data-mode="both">Both</button>
                </div>
            </div>
            
            <!-- Stroke Color (for shapes) -->
            <div id="stroke-color-section" class="setting-group hidden">
                <label class="setting-label">Stroke Color</label>
                <div class="color-picker-container">
                    <input type="color" id="stroke-color-picker" value="#000000" class="color-picker">
                    <button class="stroke-color-preset" data-color="#000000"></button>
                    <button class="stroke-color-preset" data-color="#ff0000"></button>
                    <button class="stroke-color-preset" data-color="#00ff00"></button>
                    <button class="stroke-color-preset" data-color="#0000ff"></button>
                    <button class="stroke-color-preset" data-color="#ffff00"></button>
                    <button class="stroke-color-preset" data-color="#ff00ff"></button>
                    <button class="stroke-color-preset" data-color="#00ffff"></button>
                    <button class="stroke-color-preset" data-color="#ffffff"></button>
                </div>
            </div>
            
            <!-- Fill Color (shown when fill mode is not outline) -->
            <div id="fill-color-section" class="setting-group hidden">
                <label class="setting-label">Fill Color</label>
                <div class="color-picker-container">
                    <input type="color" id="fill-color-picker" value="#000000" class="color-picker">
                    <button class="fill-color-preset" data-color="#000000"></button>
                    <button class="fill-color-preset" data-color="#ff0000"></button>
                    <button class="fill-color-preset" data-color="#00ff00"></button>
                    <button class="fill-color-preset" data-color="#0000ff"></button>
                    <button class="fill-color-preset" data-color="#ffff00"></button>
                    <button class="fill-color-preset" data-color="#ff00ff"></button>
                    <button class="fill-color-preset" data-color="#00ffff"></button>
                    <button class="fill-color-preset" data-color="#ffffff"></button>
                </div>
            </div>
            
            <!-- Corner Radius (for rectangles) -->
            <div id="corner-radius-section" class="setting-group hidden">
                <label class="setting-label">Corner Radius: <span id="corner-radius-value">0</span>px</label>
                <input type="range" id="corner-radius" min="0" max="50" value="0" class="setting-range">
                <div class="range-labels">
                    <span>0px</span>
                    <span>50px</span>
                </div>
            </div>
            
            <!-- Ellipse Aspect Ratio (for circles/ellipses) -->
            <div id="ellipse-aspect-section" class="setting-group hidden">
                <label class="setting-label">Ellipse Mode</label>
                <div class="ellipse-mode-buttons">
                    <button id="ellipse-circle" class="ellipse-mode-btn active" data-mode="circle">Circle</button>
                    <button id="ellipse-free" class="ellipse-mode-btn" data-mode="free">Free Ellipse</button>
                </div>
                <div id="aspect-ratio-controls" class="aspect-ratio-controls">
                    <label class="setting-label">Aspect Ratio: <span id="aspect-ratio-value">1.0</span></label>
                    <input type="range" id="aspect-ratio" min="0.2" max="5.0" step="0.1" value="1.0" class="setting-range">
                    <div class="range-labels">
                        <span>0.2 (tall)</span>
                        <span>5.0 (wide)</span>
                    </div>
                </div>
            </div>
        </div>
        
        <canvas id="drawing-canvas"></canvas>
        
        <!-- Pressure Sensitivity Indicator -->
        <div id="pressure-indicator" class="pressure-indicator">
            <div class="pressure-header">
                <span class="pressure-label">Pressure</span>
                <span id="pressure-value" class="pressure-value">50%</span>
            </div>
            <div class="pressure-bar-container">
                <div class="pressure-bar"></div>
            </div>
            <div class="pressure-footer">
                <span class="device-label">Mouse (Speed)</span>
                <span class="realtime-label">Real-time</span>
            </div>
        </div>
        
        <!-- Code Generation Panel -->
        <div id="code-panel" class="code-panel">
            <div class="code-header">
                <h3 class="code-title">Generated Code</h3>
                <button id="close-code-panel" class="close-code-btn">‚úï</button>
            </div>
            <select id="code-language" class="code-language-select">
                <option value="html">HTML Canvas</option>
                <option value="svg">SVG</option>
                <option value="css">CSS</option>
                <option value="javascript">JavaScript</option>
            </select>
            <textarea id="code-output" readonly class="code-output"></textarea>
            <div class="code-actions">
                <button id="copy-code" class="copy-code-btn">Copy Code</button>
                <button id="refresh-code" class="refresh-code-btn">Refresh</button>
            </div>
        </div>
    </div>

    <!-- Centralized initialization system -->
    <script>
        // The InitializationManager handles all webview startup automatically
        // It will manage API acquisition, resource loading, script coordination, and error recovery
        console.log('Webview initialization delegated to InitializationManager');
    </script>
    


            
            window.VSSCanvas.errorScreen = document.getElementById('error-screen');
            if (!window.VSSCanvas.errorScreen) {
                console.warn('VSSCanvas: Error screen element not found');
            }
            
            window.VSSCanvas.loadingStatus = document.getElementById('loading-status');
            if (!window.VSSCanvas.loadingStatus) {
                console.warn('VSSCanvas: Loading status element not found');
            }
            
            console.log('VSSCanvas: DOM references initialized');
        }
        
        // Initialize DOM references
        initializeDOMReferences();
        
        // Enhanced Drawing Tools Implementation
        window.VSSCanvas.tools = {
            pen: {
                start: function(x, y, pressure = 0.5) {
                    window.VSSCanvas.ctx.beginPath();
                    window.VSSCanvas.ctx.moveTo(x, y);
                    window.VSSCanvas.ctx.lineCap = 'round';
                    window.VSSCanvas.ctx.lineJoin = 'round';
                    
                    // Apply settings
                    const baseSize = window.VSSCanvas.settings.strokeSize;
                    const pressureMultiplier = window.VSSCanvas.settings.pressureSensitivity ? 
                        (pressure * 0.8 + 0.2) : 1.0; // 20% minimum, 100% maximum
                    
                    window.VSSCanvas.ctx.lineWidth = baseSize * pressureMultiplier;
                    window.VSSCanvas.ctx.strokeStyle = window.VSSCanvas.settings.color;
                    window.VSSCanvas.ctx.globalAlpha = window.VSSCanvas.settings.opacity;
                    
                    // Initialize smoothing
                    window.VSSCanvas.smoothedPath = [{x, y, pressure}];
                },
                draw: function(x, y, pressure = 0.5) {
                    if (window.VSSCanvas.settings.smoothing > 0) {
                        // Add point to smoothed path
                        window.VSSCanvas.smoothedPath.push({x, y, pressure});
                        
                        // Apply smoothing
                        if (window.VSSCanvas.smoothedPath.length >= 3) {
                            const smoothed = applySmoothingFilter(window.VSSCanvas.smoothedPath);
                            drawSmoothLine(smoothed);
                        }
                    } else {
                        // Direct drawing without smoothing
                        const baseSize = window.VSSCanvas.settings.strokeSize;
                        const pressureMultiplier = window.VSSCanvas.settings.pressureSensitivity ? 
                            (pressure * 0.8 + 0.2) : 1.0;
                        
                        window.VSSCanvas.ctx.lineWidth = baseSize * pressureMultiplier;
                        window.VSSCanvas.ctx.lineTo(x, y);
                        window.VSSCanvas.ctx.stroke();
                    }
                },
                end: function() {
                    window.VSSCanvas.ctx.globalAlpha = 1.0;
                    window.VSSCanvas.drawingElements.push({
                        type: 'freehand',
                        tool: 'pen',
                        color: window.VSSCanvas.settings.color,
                        width: window.VSSCanvas.settings.strokeSize,
                        opacity: window.VSSCanvas.settings.opacity,
                        timestamp: Date.now()
                    });
                    window.VSSCanvas.smoothedPath = [];
                }
            },
            
            rectangle: {
                start: function(x, y) {
                    window.VSSCanvas.startX = x;
                    window.VSSCanvas.startY = y;
                    window.VSSCanvas.isDrawingShape = true;
                },
                draw: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    // Clear and redraw
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                    
                    // Draw preview rectangle
                    window.VSSCanvas.ctx.strokeStyle = '#007acc';
                    window.VSSCanvas.ctx.lineWidth = 2;
                    window.VSSCanvas.ctx.strokeRect(
                        window.VSSCanvas.startX, 
                        window.VSSCanvas.startY, 
                        x - window.VSSCanvas.startX, 
                        y - window.VSSCanvas.startY
                    );
                },
                end: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    const rect = {
                        type: 'rectangle',
                        x: Math.min(window.VSSCanvas.startX, x),
                        y: Math.min(window.VSSCanvas.startY, y),
                        width: Math.abs(x - window.VSSCanvas.startX),
                        height: Math.abs(y - window.VSSCanvas.startY),
                        color: '#007acc',
                        lineWidth: 2,
                        timestamp: Date.now()
                    };
                    
                    window.VSSCanvas.drawingElements.push(rect);
                    window.VSSCanvas.isDrawingShape = false;
                    
                    // Redraw everything
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                }
            },
            
            circle: {
                start: function(x, y) {
                    window.VSSCanvas.startX = x;
                    window.VSSCanvas.startY = y;
                    window.VSSCanvas.isDrawingShape = true;
                },
                draw: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    const radius = Math.sqrt(Math.pow(x - window.VSSCanvas.startX, 2) + Math.pow(y - window.VSSCanvas.startY, 2));
                    
                    // Clear and redraw
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                    
                    // Draw preview circle
                    window.VSSCanvas.ctx.strokeStyle = '#28a745';
    <!-- 
    All VSSCanvas initialization and drawing functionality has been moved to external scripts
    that are loaded and managed by the InitializationManager. This provides better error
    handling, proper dependency management, and cleaner separation of concerns.
    -->
            window.VSSCanvas.ctx.lineWidth = 2;
            
            console.log('VSSCanvas: Canvas initialization completed');
            updateStatus('Canvas ready for drawing');
        }
        
        function resizeCanvas() {
            if (!window.VSSCanvas.canvas) {
                console.warn('VSSCanvas: Cannot resize canvas - canvas not initialized');
                return;
            }
            
            const container = document.getElementById('canvas-container');
            if (!container) {
                console.warn('VSSCanvas: Cannot resize canvas - container element not found');
                return;
            }
            
            const statusElement = document.getElementById('status');
            const statusHeight = statusElement ? statusElement.offsetHeight : 0;
            
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight - statusHeight;
            
            // Ensure we have valid dimensions (avoid 0x0 canvas)
            const finalWidth = Math.max(newWidth, 300);
            const finalHeight = Math.max(newHeight, 200);
            
            // Get device pixel ratio for high DPI displays
            const dpr = window.devicePixelRatio || 1;
            
            // Only resize if dimensions have changed to avoid unnecessary redraws
            if (window.VSSCanvas.canvas.width !== finalWidth * dpr || window.VSSCanvas.canvas.height !== finalHeight * dpr) {
                console.log(`VSSCanvas: Resizing canvas from ${window.VSSCanvas.canvas.width}x${window.VSSCanvas.canvas.height} to ${finalWidth * dpr}x${finalHeight * dpr} (container: ${newWidth}x${newHeight}, DPR: ${dpr})`);
                
                // Set actual canvas size in memory (scaled for high DPI)
                window.VSSCanvas.canvas.width = finalWidth * dpr;
                window.VSSCanvas.canvas.height = finalHeight * dpr;
                
                // Set display size (CSS pixels)
                window.VSSCanvas.canvas.style.width = finalWidth + 'px';
                window.VSSCanvas.canvas.style.height = finalHeight + 'px';
                
                // Scale the drawing context to match device pixel ratio
                window.VSSCanvas.ctx.scale(dpr, dpr);
                
                // Restore drawing properties after resize (they get reset when canvas dimensions change)
                if (window.VSSCanvas.ctx) {
                    window.VSSCanvas.ctx.lineCap = 'round';
                    window.VSSCanvas.ctx.lineJoin = 'round';
                    window.VSSCanvas.ctx.strokeStyle = '#000000';
                    window.VSSCanvas.ctx.lineWidth = 2;
                }
            }
        }
        
        function setupEventListeners() {
            console.log('VSSCanvas: Setting up event listeners...');
            
            // Window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Tool buttons with existence check
            const toolButtons = document.querySelectorAll('.tool-button[data-tool]');
            if (toolButtons.length > 0) {
                toolButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        selectTool(this.dataset.tool);
                    });
                });
                console.log(`VSSCanvas: Added event listeners to ${toolButtons.length} tool buttons`);
            } else {
                console.warn('VSSCanvas: No tool buttons found');
            }
            
            // Clear canvas button with existence check
            const clearButton = document.getElementById('clear-canvas');
            if (clearButton) {
                clearButton.addEventListener('click', clearCanvas);
                console.log('VSSCanvas: Added event listener to clear button');
            } else {
                console.warn('VSSCanvas: Clear canvas button not found');
            }
            
            // Canvas drawing events with existence check
            if (window.VSSCanvas.canvas) {
                // Mouse events for drawing
                window.VSSCanvas.canvas.addEventListener('mousedown', startDrawing);
                window.VSSCanvas.canvas.addEventListener('mousemove', draw);
                window.VSSCanvas.canvas.addEventListener('mouseup', stopDrawing);
                window.VSSCanvas.canvas.addEventListener('mouseout', stopDrawing);
                
                // Touch events for mobile/tablet support
                window.VSSCanvas.canvas.addEventListener('touchstart', handleTouch);
                window.VSSCanvas.canvas.addEventListener('touchmove', handleTouch);
                window.VSSCanvas.canvas.addEventListener('touchend', stopDrawing);
                
                console.log('VSSCanvas: Added drawing event listeners to canvas');
            } else {
                console.error('VSSCanvas: Cannot add drawing event listeners - canvas not initialized');
                throw new Error('Canvas not initialized before setting up event listeners');
            }
            
            // Settings panel event listeners
            const settingsToggle = document.getElementById('settings-toggle');
            const settingsPanel = document.getElementById('settings-panel');
            const closeSettings = document.getElementById('close-settings');
            
            if (settingsToggle && settingsPanel) {
                settingsToggle.addEventListener('click', function() {
                    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
                });
            }
            
            if (closeSettings && settingsPanel) {
                closeSettings.addEventListener('click', function() {
                    settingsPanel.style.display = 'none';
                });
            }
            
            // Stroke size control
            const strokeSizeSlider = document.getElementById('stroke-size');
            const strokeSizeValue = document.getElementById('stroke-size-value');
            if (strokeSizeSlider && strokeSizeValue) {
                strokeSizeSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.strokeSize = parseInt(this.value);
                    strokeSizeValue.textContent = this.value;
                });
            }
            
            // Opacity control
            const opacitySlider = document.getElementById('opacity');
            const opacityValue = document.getElementById('opacity-value');
            if (opacitySlider && opacityValue) {
                opacitySlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.opacity = parseInt(this.value) / 100;
                    opacityValue.textContent = this.value;
                });
            }
            
            // Color picker
            const colorPicker = document.getElementById('color-picker');
            if (colorPicker) {
                colorPicker.addEventListener('change', function() {
                    window.VSSCanvas.settings.color = this.value;
                });
            }
            
            // Color presets
            const colorPresets = document.querySelectorAll('.color-preset');
            colorPresets.forEach(preset => {
                preset.addEventListener('click', function() {
                    const color = this.dataset.color;
                    window.VSSCanvas.settings.color = color;
                    if (colorPicker) colorPicker.value = color;
                });
            });
            
            // Pressure sensitivity toggle
            const pressureSensitivity = document.getElementById('pressure-sensitivity');
            if (pressureSensitivity) {
                pressureSensitivity.addEventListener('change', function() {
                    window.VSSCanvas.settings.pressureSensitivity = this.checked;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setEnabled(this.checked);
                    }
                    
                    // Show/hide pressure range controls
                    const pressureRangeControls = document.getElementById('pressure-range-controls');
                    if (pressureRangeControls) {
                        pressureRangeControls.style.display = this.checked ? 'block' : 'none';
                    }
                });
            }
            
            // Min pressure control
            const minPressureSlider = document.getElementById('min-pressure');
            const minPressureValue = document.getElementById('min-pressure-value');
            if (minPressureSlider && minPressureValue) {
                minPressureSlider.addEventListener('input', function() {
                    const minValue = parseInt(this.value);
                    window.VSSCanvas.settings.minPressure = minValue / 100;
                    minPressureValue.textContent = minValue;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setPressureRange(
                            window.VSSCanvas.settings.minPressure,
                            window.VSSCanvas.settings.maxPressure
                        );
                    }
                    
                    // Ensure min doesn't exceed max
                    const maxPressureSlider = document.getElementById('max-pressure');
                    if (maxPressureSlider && minValue >= parseInt(maxPressureSlider.value)) {
                        maxPressureSlider.value = minValue + 10;
                        const maxPressureValue = document.getElementById('max-pressure-value');
                        if (maxPressureValue) {
                            maxPressureValue.textContent = maxPressureSlider.value;
                            window.VSSCanvas.settings.maxPressure = parseInt(maxPressureSlider.value) / 100;
                        }
                    }
                });
            }
            
            // Max pressure control
            const maxPressureSlider = document.getElementById('max-pressure');
            const maxPressureValue = document.getElementById('max-pressure-value');
            if (maxPressureSlider && maxPressureValue) {
                maxPressureSlider.addEventListener('input', function() {
                    const maxValue = parseInt(this.value);
                    window.VSSCanvas.settings.maxPressure = maxValue / 100;
                    maxPressureValue.textContent = maxValue;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setPressureRange(
                            window.VSSCanvas.settings.minPressure,
                            window.VSSCanvas.settings.maxPressure
                        );
                    }
                    
                    // Ensure max doesn't go below min
                    const minPressureSlider = document.getElementById('min-pressure');
                    if (minPressureSlider && maxValue <= parseInt(minPressureSlider.value)) {
                        minPressureSlider.value = maxValue - 10;
                        const minPressureValue = document.getElementById('min-pressure-value');
                        if (minPressureValue) {
                            minPressureValue.textContent = minPressureSlider.value;
                            window.VSSCanvas.settings.minPressure = parseInt(minPressureSlider.value) / 100;
                        }
                    }
                });
            }
            
            // Mouse speed pressure toggle
            const mouseSpeedPressure = document.getElementById('mouse-speed-pressure');
            if (mouseSpeedPressure) {
                mouseSpeedPressure.addEventListener('change', function() {
                    window.VSSCanvas.settings.mouseSpeedPressure = this.checked;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setMouseSpeedPressure(this.checked);
                    }
                });
            }
            
            // Pressure feedback toggle
            const pressureFeedback = document.getElementById('pressure-feedback');
            if (pressureFeedback) {
                pressureFeedback.addEventListener('change', function() {
                    window.VSSCanvas.settings.pressureFeedback = this.checked;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setFeedbackEnabled(this.checked);
                    }
                });
            }
            
            // Initialize pressure controls visibility and values
            function initializePressureControls() {
                // Set initial visibility of pressure range controls
                const pressureRangeControls = document.getElementById('pressure-range-controls');
                const pressureSensitivityCheckbox = document.getElementById('pressure-sensitivity');
                
                if (pressureRangeControls && pressureSensitivityCheckbox) {
                    pressureRangeControls.style.display = pressureSensitivityCheckbox.checked ? 'block' : 'none';
                }
                
                // Set initial values from settings
                if (minPressureSlider && minPressureValue) {
                    minPressureSlider.value = window.VSSCanvas.settings.minPressure * 100;
                    minPressureValue.textContent = Math.round(window.VSSCanvas.settings.minPressure * 100);
                }
                
                if (maxPressureSlider && maxPressureValue) {
                    maxPressureSlider.value = window.VSSCanvas.settings.maxPressure * 100;
                    maxPressureValue.textContent = Math.round(window.VSSCanvas.settings.maxPressure * 100);
                }
                
                if (mouseSpeedPressure) {
                    mouseSpeedPressure.checked = window.VSSCanvas.settings.mouseSpeedPressure;
                }
                
                if (pressureFeedback) {
                    pressureFeedback.checked = window.VSSCanvas.settings.pressureFeedback;
                }
                
                console.log('Pressure controls initialized');
            }
            
            // Call initialization
            initializePressureControls();
            
            // Smoothing control
            const smoothingSlider = document.getElementById('smoothing');
            const smoothingValue = document.getElementById('smoothing-value');
            if (smoothingSlider && smoothingValue) {
                smoothingSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.smoothing = parseInt(this.value);
                    smoothingValue.textContent = this.value;
                });
            }
            
            // Fill mode buttons
            const fillModeButtons = document.querySelectorAll('.fill-mode-btn');
            fillModeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Update active state
                    fillModeButtons.forEach(btn => {
                        btn.classList.remove('active');
                        btn.style.background = '#3c3c3c';
                        btn.style.color = '#cccccc';
                    });
                    this.classList.add('active');
                    this.style.background = '#007acc';
                    this.style.color = 'white';
                    
                    // Update setting
                    window.VSSCanvas.settings.fillMode = this.dataset.mode;
                    
                    // Show/hide fill color section
                    const fillColorSection = document.getElementById('fill-color-section');
                    if (fillColorSection) {
                        fillColorSection.style.display = 
                            (this.dataset.mode === 'outline') ? 'none' : 'block';
                    }
                });
            });
            
            // Fill color picker
            const fillColorPicker = document.getElementById('fill-color-picker');
            if (fillColorPicker) {
                fillColorPicker.addEventListener('change', function() {
                    window.VSSCanvas.settings.fillColor = this.value;
                });
            }
            
            // Fill color presets
            const fillColorPresets = document.querySelectorAll('.fill-color-preset');
            fillColorPresets.forEach(preset => {
                preset.addEventListener('click', function() {
                    const color = this.dataset.color;
                    window.VSSCanvas.settings.fillColor = color;
                    if (fillColorPicker) fillColorPicker.value = color;
                });
            });
            
            // Corner radius control
            const cornerRadiusSlider = document.getElementById('corner-radius');
            const cornerRadiusValue = document.getElementById('corner-radius-value');
            if (cornerRadiusSlider && cornerRadiusValue) {
                cornerRadiusSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.cornerRadius = parseInt(this.value);
                    cornerRadiusValue.textContent = this.value;
                });
            }
            
            // Ellipse mode buttons
            const ellipseModeButtons = document.querySelectorAll('.ellipse-mode-btn');
            ellipseModeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Update active state
                    ellipseModeButtons.forEach(btn => {
                        btn.classList.remove('active');
                        btn.style.background = '#3c3c3c';
                        btn.style.color = '#cccccc';
                    });
                    this.classList.add('active');
                    this.style.background = '#007acc';
                    this.style.color = 'white';
                    
                    // Update setting
                    window.VSSCanvas.settings.ellipseMode = this.dataset.mode;
                    
                    // Show/hide aspect ratio controls
                    const aspectRatioControls = document.getElementById('aspect-ratio-controls');
                    if (aspectRatioControls) {
                        aspectRatioControls.style.display = 
                            (this.dataset.mode === 'free') ? 'block' : 'none';
                    }
                });
            });
            
            // Aspect ratio control
            const aspectRatioSlider = document.getElementById('aspect-ratio');
            const aspectRatioValue = document.getElementById('aspect-ratio-value');
            if (aspectRatioSlider && aspectRatioValue) {
                aspectRatioSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.aspectRatio = parseFloat(this.value);
                    aspectRatioValue.textContent = parseFloat(this.value).toFixed(1);
                });
            }
            
            // Generate code button
            const generateCodeBtn = document.getElementById('generate-code');
            const codePanel = document.getElementById('code-panel');
            if (generateCodeBtn && codePanel) {
                generateCodeBtn.addEventListener('click', function() {
                    generateCode();
                    codePanel.style.display = codePanel.style.display === 'none' ? 'block' : 'none';
                });
            }
            
            // Close code panel
            const closeCodePanel = document.getElementById('close-code-panel');
            if (closeCodePanel && codePanel) {
                closeCodePanel.addEventListener('click', function() {
                    codePanel.style.display = 'none';
                });
            }
            
            // Copy code functionality
            const copyCodeBtn = document.getElementById('copy-code');
            const refreshCodeBtn = document.getElementById('refresh-code');
            const codeOutput = document.getElementById('code-output');
            
            if (copyCodeBtn && codeOutput) {
                copyCodeBtn.addEventListener('click', function() {
                    codeOutput.select();
                    document.execCommand('copy');
                    
                    // Visual feedback
                    const originalText = this.textContent;
                    this.textContent = 'Copied!';
                    this.style.background = '#28a745';
                    
                    setTimeout(() => {
                        this.textContent = originalText;
                        this.style.background = '#007acc';
                    }, 1000);
                });
            }
            
            if (refreshCodeBtn) {
                refreshCodeBtn.addEventListener('click', function() {
                    generateCode();
                });
            }
            
            // Language selector change
            const languageSelector = document.getElementById('code-language');
            if (languageSelector) {
                languageSelector.addEventListener('change', function() {
                    generateCode();
                });
            }
            
            console.log('VSSCanvas: Event listeners setup completed');
        }
        
        function setupMessagePassing() {
            // Listen for messages from VS Code extension
            window.addEventListener('message', event => {
                const message = event.data;
                
                switch (message.command) {
                    case 'clearCanvas':
                        clearCanvas();
                        break;
                    case 'setTool':
                        selectTool(message.tool);
                        break;
                    case 'connectionStatus':
                        updateConnectionStatus(message.connected);
                        break;
                    default:
                        console.log('Unknown message:', message);
                }
            });
            
            // Send initial ready message to extension
            sendMessage({
                command: 'canvasReady',
                data: {
                    width: window.VSSCanvas.canvas.width,
                    height: window.VSSCanvas.canvas.height
                }
            });
        }
        
        function sendMessage(message) {
            try {
                // Check if VS Code API is available
                if (!window.VSSCanvas.vscode) {
                    console.warn('VSSCanvas: VS Code API not available, cannot send message:', message);
                    return false;
                }
                
                window.VSSCanvas.vscode.postMessage(message);
                return true;
            } catch (error) {
                console.error('VSSCanvas: Error sending message to extension:', error);
                updateStatus('Communication error with extension');
                
                // If we're not initialized yet, show error screen
                if (!window.VSSCanvas.hasInitialized) {
                    showError('Failed to communicate with VS Code extension: ' + error.message, error.stack);
                }
                return false;
            }
        }
        
        function selectTool(tool) {
            window.VSSCanvas.currentTool = tool;
            
            // Update button states
            document.querySelectorAll('.tool-button[data-tool]').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            // Update cursor
            window.VSSCanvas.canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
            
            // Show/hide shape-specific settings
            updateShapeSettings(tool);
            
            updateStatus(`Selected tool: ${tool}`);
            
            // Notify extension of tool change
            sendMessage({
                command: 'toolChanged',
                data: { tool: tool }
            });
        }
        
        function updateShapeSettings(tool) {
            const shapeFillMode = document.getElementById('shape-fill-mode');
            const fillColorSection = document.getElementById('fill-color-section');
            const cornerRadiusSection = document.getElementById('corner-radius-section');
            const ellipseAspectSection = document.getElementById('ellipse-aspect-section');
            
            // Hide all shape settings by default
            if (shapeFillMode) shapeFillMode.style.display = 'none';
            if (fillColorSection) fillColorSection.style.display = 'none';
            if (cornerRadiusSection) cornerRadiusSection.style.display = 'none';
            if (ellipseAspectSection) ellipseAspectSection.style.display = 'none';
            
            // Show relevant settings for shape tools
            if (tool === 'rectangle' || tool === 'circle' || tool === 'line') {
                if (shapeFillMode) shapeFillMode.style.display = 'block';
                
                // Show fill color if not in outline mode
                if (window.VSSCanvas.settings.fillMode !== 'outline' && fillColorSection) {
                    fillColorSection.style.display = 'block';
                }
                
                // Show corner radius only for rectangles
                if (tool === 'rectangle' && cornerRadiusSection) {
                    cornerRadiusSection.style.display = 'block';
                }
                
                // Show ellipse aspect controls only for circles
                if (tool === 'circle' && ellipseAspectSection) {
                    ellipseAspectSection.style.display = 'block';
                }
            }
        }
        
        function startDrawing(e) {
            window.VSSCanvas.isDrawing = true;
            [window.VSSCanvas.lastX, window.VSSCanvas.lastY] = getMousePos(e);
            
            // Get pressure information
            const pressure = getPressureFromEvent(e);
            
            // Use enhanced tools system
            if (window.VSSCanvas.tools && window.VSSCanvas.tools[window.VSSCanvas.currentTool]) {
                window.VSSCanvas.tools[window.VSSCanvas.currentTool].start(window.VSSCanvas.lastX, window.VSSCanvas.lastY, pressure);
            } else {
                // Fallback to basic drawing
                window.VSSCanvas.ctx.beginPath();
                window.VSSCanvas.ctx.moveTo(window.VSSCanvas.lastX, window.VSSCanvas.lastY);
            }
            
            sendMessage({
                command: 'drawingStarted',
                data: { 
                    tool: window.VSSCanvas.currentTool,
                    x: window.VSSCanvas.lastX, 
                    y: window.VSSCanvas.lastY,
                    pressure: pressure
                }
            });
        }
        
        function draw(e) {
            if (!window.VSSCanvas.isDrawing) return;
            
            const [currentX, currentY] = getMousePos(e);
            const pressure = getPressureFromEvent(e);
            
            // Use enhanced tools system
            if (window.VSSCanvas.tools && window.VSSCanvas.tools[window.VSSCanvas.currentTool]) {
                window.VSSCanvas.tools[window.VSSCanvas.currentTool].draw(currentX, currentY, pressure);
            } else {
                // Fallback to basic drawing
                if (window.VSSCanvas.currentTool === 'pen') {
                    window.VSSCanvas.ctx.globalCompositeOperation = 'source-over';
                    window.VSSCanvas.ctx.strokeStyle = window.VSSCanvas.settings.color;
                    window.VSSCanvas.ctx.lineWidth = window.VSSCanvas.settings.strokeSize;
                } else if (window.VSSCanvas.currentTool === 'eraser') {
                    window.VSSCanvas.ctx.globalCompositeOperation = 'destination-out';
                    window.VSSCanvas.ctx.lineWidth = window.VSSCanvas.settings.strokeSize * 2;
                }
                
                window.VSSCanvas.ctx.lineTo(currentX, currentY);
                window.VSSCanvas.ctx.stroke();
            }
            
            [window.VSSCanvas.lastX, window.VSSCanvas.lastY] = [currentX, currentY];
            
            // Send drawing data to extension (throttled)
            if (Math.random() < 0.1) { // Only send 10% of drawing events to avoid spam
                sendMessage({
                    command: 'drawing',
                    data: {
                        tool: window.VSSCanvas.currentTool,
                        x: currentX,
                        y: currentY,
                        lastX: window.VSSCanvas.lastX,
                        lastY: window.VSSCanvas.lastY
                    }
                });
            }
        }
        
        function stopDrawing() {
            if (!window.VSSCanvas.isDrawing) return;
            
            window.VSSCanvas.isDrawing = false;
            window.VSSCanvas.ctx.beginPath(); // Reset path
            
            sendMessage({
                command: 'drawingEnded',
                data: { tool: window.VSSCanvas.currentTool }
            });
        }
        
        function handleTouch(e) {
            e.preventDefault();
            
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                            e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            
            window.VSSCanvas.canvas.dispatchEvent(mouseEvent);
        }
        
        function getMousePos(e) {
            const rect = window.VSSCanvas.canvas.getBoundingClientRect();
            // No need to scale by DPR here since we're working in CSS pixels
            // The scaling is handled by the context.scale() in resizeCanvas
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }
        
        function clearCanvas() {
            window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
            updateStatus('Canvas cleared');
            
            sendMessage({
                command: 'canvasCleared',
                data: {}
            });
        }
        
        function updateStatus(message) {
            const statusElement = document.getElementById('status');
            const statusText = statusElement.querySelector('span:first-child');
            statusText.textContent = `VSS Drawing Canvas - ${message}`;
        }
        
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connection-status');
            statusElement.textContent = connected ? 'Connected' : 'Disconnected';
            statusElement.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
        }
        
        // Start connection monitoring after initialization
        function startConnectionMonitoring() {
            window.VSSCanvas.connectionCheckInterval = setInterval(function() {
                const timeSinceLastMessage = Date.now() - window.VSSCanvas.lastMessageTime;
                const isConnected = timeSinceLastMessage < 30000; // 30 seconds timeout
                updateConnectionStatus(isConnected);
            }, 5000);
        }

        // Listen for messages from extension to track connection
        window.addEventListener('message', function(event) {
            window.VSSCanvas.lastMessageTime = Date.now();
            updateConnectionStatus(true);
        });

        // Start monitoring once canvas is ready
        setTimeout(function() {
            if (window.VSSCanvas.hasInitialized) {
                startConnectionMonitoring();
            }
        }, 1000);

        // Cleanup on unload
        window.addEventListener('beforeunload', function() {
            if (window.VSSCanvas.connectionCheckInterval) {
                clearInterval(window.VSSCanvas.connectionCheckInterval);
            }
            if (window.VSSCanvas.initializationTimeout) {
                clearTimeout(window.VSSCanvas.initializationTimeout);
            }
        });
        
        // Add methods to the existing VSSCanvas namespace
        window.VSSCanvas.init = function() {
            console.log('VSSCanvas: Starting initialization for instance ID:', this.instanceId);
            
            if (this.initialized) {
                console.log('VSSCanvas: Already initialized, performing cleanup before reinitializing...');
                this.cleanup();
            }
            
            try {
                // Mark initialization start time for debugging
                this.initStartedAt = new Date().toISOString();
                
                updateLoadingStatus('Initializing canvas...');
                initializeCanvas();
                
                updateLoadingStatus('Setting up drawing tools...');
                setupEventListeners();
                
                updateLoadingStatus('Establishing connection...');
                setupMessagePassing();
                
                updateLoadingStatus('Canvas ready!');
                updateStatus('Canvas initialized successfully');
                
                // Mark as initialized
                this.initialized = true;
                this.initCompletedAt = new Date().toISOString();
                
                console.log('VSSCanvas: Initialization completed successfully for instance ID:', this.instanceId);
                
                // Hide loading screen after a short delay
                setTimeout(function() {
                    if (window.VSSCanvas.initializationTimeout) {
                        clearTimeout(window.VSSCanvas.initializationTimeout);
                        window.VSSCanvas.initializationTimeout = null;
                    }
                    hideLoadingScreen();
                }, 500);
                
                return true;
            } catch (error) {
                console.error('VSSCanvas: Initialization failed for instance ID:', this.instanceId, error);
                
                // Clear initialization timeout on error
                if (this.initializationTimeout) {
                    clearTimeout(this.initializationTimeout);
                    this.initializationTimeout = null;
                }
                
                // Mark initialization failure time for debugging
                this.initFailedAt = new Date().toISOString();
                this.lastInitError = error.message;
                
                showError('Initialization failed: ' + error.message, error.stack);
                return false;
            }
        };
        
        // Cleanup method with comprehensive existence checks
        window.VSSCanvas.cleanup = function() {
            console.log('VSSCanvas: Starting cleanup for instance ID:', this.instanceId);
            
            try {
                // Clear timeouts with existence checks
                if (this.initializationTimeout) {
                    console.log('VSSCanvas: Clearing initialization timeout');
                    clearTimeout(this.initializationTimeout);
                    this.initializationTimeout = null;
                }
                
                if (this.connectionCheckInterval) {
                    console.log('VSSCanvas: Clearing connection check interval');
                    clearInterval(this.connectionCheckInterval);
                    this.connectionCheckInterval = null;
                }
                
                // Clear canvas if it exists and is valid
                if (this.ctx && this.canvas) {
                    try {
                        console.log('VSSCanvas: Clearing canvas content');
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    } catch (canvasError) {
                        console.warn('VSSCanvas: Error clearing canvas:', canvasError);
                    }
                }
                
                // Reset state variables
                this.hasInitialized = false;
                this.isDrawing = false;
                this.currentTool = 'pen';
                this.lastX = 0;
                this.lastY = 0;
                
                // Reset DOM references
                this.loadingScreen = null;
                this.errorScreen = null;
                this.loadingStatus = null;
                
                // Reset canvas references
                this.canvas = null;
                this.ctx = null;
                
                // Reset initialization flag
                this.initialized = false;
                
                // Update timestamp for debugging
                this.lastCleanupAt = new Date().toISOString();
                
                console.log('VSSCanvas: Cleanup completed successfully for instance ID:', this.instanceId);
                
            } catch (cleanupError) {
                console.error('VSSCanvas: Error during cleanup:', cleanupError);
                // Continue with cleanup even if some parts fail
                this.initialized = false;
                this.hasInitialized = false;
            }
        };
        
        // Check if canvas is initialized
        window.VSSCanvas.isInitialized = function() {
            return this.initialized && this.hasInitialized;
        };
        
        // Get current canvas state
        window.VSSCanvas.getState = function() {
            return {
                initialized: this.initialized,
                hasInitialized: this.hasInitialized,
                isDrawing: this.isDrawing,
                currentTool: this.currentTool,
                canvasSize: this.canvas ? { width: this.canvas.width, height: this.canvas.height } : null
            };
        };
        
        // Force reinitialization
        window.VSSCanvas.reinitialize = function() {
            this.cleanup();
            return this.init();
        };
        
        // Initialize ResourceURIBuilder for proper vscode-resource URI handling
        // This will be handled by the ScriptLoadingCoordinator when dependencies are ready
        if (window.ScriptLoadingCoordinator) {
            const coordinator = window.ScriptLoadingCoordinator.getInstance();
            
            // Register callback for when all scripts are loaded
            coordinator.onAllScriptsLoaded(() => {
                if (window.ResourceURIBuilder && window.VSCodeAPIManager) {
                    const resourceBuilder = new window.ResourceURIBuilder();
                    
                    // Wait for VS Code API to be ready, then initialize ResourceURIBuilder
                    window.VSCodeAPIManager.onAPIReady(() => {
                        try {
                            const vscodeApi = window.VSCodeAPIManager.getAPI();
                            
                            // Initialize with available context
                            resourceBuilder.initialize(vscodeApi, null, null);
                            
                            // Update all existing resource references to use proper URIs
                            const updateResults = resourceBuilder.updateAllResourceReferences();
                            console.log('Resource URI updates completed:', updateResults);
                            
                            // Make resourceBuilder globally available
                            window.resourceBuilder = resourceBuilder;
                            
                        } catch (error) {
                            console.error('Failed to initialize ResourceURIBuilder:', error);
                        }
                    });
                }
            });
        }
        
        })(); // End of IIFE
    </script>
</body>
</html>