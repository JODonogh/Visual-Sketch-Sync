<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; script-src 'unsafe-inline';">
    <title>VSS Drawing Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            color: #cccccc;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        #status {
            background: rgba(30, 30, 30, 0.9);
            color: #cccccc;
            padding: 8px 12px;
            font-size: 12px;
            border-bottom: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #drawing-canvas {
            flex: 1;
            background: white;
            cursor: crosshair;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .toolbar {
            position: absolute;
            top: 50px;
            left: 10px;
            background: rgba(30, 30, 30, 0.9);
            border-radius: 6px;
            padding: 6px;
            display: flex;
            gap: 6px;
            z-index: 100;
            height: 30px;
            align-items: center;
        }
        
        .tool-button {
            background: #3c3c3c;
            border: none;
            color: #cccccc;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }
        
        .tool-button:hover {
            background: #4c4c4c;
        }
        
        .tool-button.active {
            background: #007acc;
        }
        
        /* Responsive design for compact toolbar */
        @media (max-width: 768px) {
            .toolbar {
                gap: 4px;
                padding: 4px;
                height: 28px;
            }
            
            .tool-button {
                padding: 3px 6px;
                font-size: 10px;
                height: 22px;
                min-width: 22px;
            }
        }
        
        @media (max-width: 480px) {
            .toolbar {
                gap: 3px;
                padding: 3px;
                height: 26px;
            }
            
            .tool-button {
                padding: 2px 4px;
                font-size: 9px;
                height: 20px;
                min-width: 20px;
            }
        }
        
        .connection-status {
            font-size: 11px;
            color: #999;
        }
        
        .connection-status.connected {
            color: #28a745;
        }
        
        .connection-status.disconnected {
            color: #dc3545;
        }
        
        /* Loading Screen Styles */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: #cccccc;
        }

        .loading-spinner {
            margin-bottom: 20px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #333;
            border-top: 4px solid #007acc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            text-align: center;
        }

        .loading-text h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
            font-weight: 500;
        }

        .loading-text p {
            margin: 0;
            font-size: 14px;
            color: #999;
        }

        /* Hide canvas container when loading screen is visible */
        .loading-screen:not([style*="display: none"]) ~ #canvas-container {
            display: none;
        }
        
        /* Error Screen Styles */
        .error-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9998;
            color: #cccccc;
        }

        .error-content {
            max-width: 500px;
            padding: 30px;
            background: #2d2d2d;
            border-radius: 8px;
            border: 1px solid #444;
            text-align: center;
        }

        .error-content h2 {
            color: #f48771;
            margin: 0 0 20px 0;
            font-size: 24px;
        }

        .error-message {
            background: #3c1e1e;
            border: 1px solid #d32f2f;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
            color: #ffcdd2;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .error-actions {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .retry-button, .report-button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .retry-button {
            background: #007acc;
            color: white;
        }

        .retry-button:hover {
            background: #005a9e;
        }

        .report-button {
            background: #444;
            color: #cccccc;
        }

        .report-button:hover {
            background: #555;
        }

        .error-details {
            margin-top: 20px;
            text-align: left;
        }

        .error-details summary {
            cursor: pointer;
            color: #999;
            font-size: 12px;
        }

        .error-details pre {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 11px;
            color: #ccc;
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* Hide canvas container when error is shown */
        .error-screen:not([style*="display: none"]) ~ #canvas-container {
            display: none;
        }
        
        /* Pressure Sensitivity Styles */
        #pressure-indicator {
            transition: opacity 0.3s ease;
        }
        
        #pressure-indicator.active {
            display: block !important;
            opacity: 1;
        }
        
        #pressure-indicator:not(.active) {
            opacity: 0;
        }
        
        .pressure-bar {
            transition: width 0.1s ease, background-color 0.1s ease;
        }
        
        #pressure-cursor {
            transition: width 0.1s ease, height 0.1s ease;
        }
        
        /* Settings panel pressure controls */
        #pressure-range-controls {
            transition: opacity 0.3s ease;
        }
        
        #pressure-range-controls input[type="range"] {
            height: 4px;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        #pressure-range-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #007acc;
            cursor: pointer;
        }
        
        #pressure-range-controls input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #007acc;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div id="loading-screen" class="loading-screen">
        <div class="loading-spinner">
            <div class="spinner"></div>
        </div>
        <div class="loading-text">
            <h3>Loading Drawing Canvas...</h3>
            <p id="loading-status">Initializing components...</p>
        </div>
    </div>
    
    <div id="error-screen" class="error-screen" style="display: none;">
        <div class="error-content">
            <h2>⚠️ Canvas Error</h2>
            <div id="error-message" class="error-message"></div>
            <div class="error-actions">
                <button id="retry-button" class="retry-button">Retry</button>
                <button id="report-button" class="report-button">Report Issue</button>
            </div>
            <details class="error-details">
                <summary>Technical Details</summary>
                <pre id="error-stack"></pre>
            </details>
        </div>
    </div>
    
    <div id="canvas-container">
        <div id="status">
            <span>VSS Drawing Canvas - Ready</span>
            <span class="connection-status disconnected" id="connection-status">Disconnected</span>
        </div>
        
        <div class="toolbar">
            <button class="tool-button active" data-tool="pen" id="pen-tool">✏️ Pen</button>
            <button class="tool-button" data-tool="rectangle" id="rectangle-tool">⬜ Rectangle</button>
            <button class="tool-button" data-tool="circle" id="circle-tool">⭕ Circle</button>
            <button class="tool-button" data-tool="line" id="line-tool">📏 Line</button>
            <button class="tool-button" data-tool="eraser" id="eraser-tool">🧽 Eraser</button>
            <button class="tool-button" id="clear-canvas">🗑️ Clear</button>
            <button class="tool-button" id="generate-code">💻 Generate Code</button>
            <button class="tool-button" id="settings-toggle">⚙️ Settings</button>
        </div>
        
        <!-- Settings Panel -->
        <div id="settings-panel" style="display: none; position: absolute; top: 100px; left: 10px; width: 250px; background: rgba(30, 30, 30, 0.95); border: 1px solid #555; border-radius: 8px; padding: 15px; z-index: 150;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0; color: #cccccc; font-size: 16px;">Drawing Settings</h3>
                <button id="close-settings" style="background: none; border: none; color: #999; cursor: pointer; font-size: 16px;">✕</button>
            </div>
            
            <!-- Stroke Size -->
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Stroke Size: <span id="stroke-size-value">5</span>px</label>
                <input type="range" id="stroke-size" min="1" max="50" value="5" style="width: 100%; background: #3c3c3c;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: #999; margin-top: 2px;">
                    <span>1px</span>
                    <span>50px</span>
                </div>
            </div>
            
            <!-- Opacity -->
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Opacity: <span id="opacity-value">100</span>%</label>
                <input type="range" id="opacity" min="10" max="100" value="100" style="width: 100%; background: #3c3c3c;">
            </div>
            
            <!-- Color Picker -->
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Color</label>
                <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                    <input type="color" id="color-picker" value="#000000" style="width: 40px; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                    <button class="color-preset" data-color="#000000" style="width: 25px; height: 25px; background: #000000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#ff0000" style="width: 25px; height: 25px; background: #ff0000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#00ff00" style="width: 25px; height: 25px; background: #00ff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#0000ff" style="width: 25px; height: 25px; background: #0000ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#ffff00" style="width: 25px; height: 25px; background: #ffff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#ff00ff" style="width: 25px; height: 25px; background: #ff00ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#00ffff" style="width: 25px; height: 25px; background: #00ffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="color-preset" data-color="#ffffff" style="width: 25px; height: 25px; background: #ffffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                </div>
            </div>
            
            <!-- Pressure Sensitivity -->
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; color: #cccccc; font-size: 12px; margin-bottom: 8px;">
                    <input type="checkbox" id="pressure-sensitivity" checked style="margin-right: 8px;">
                    Enable Pressure Sensitivity
                </label>
                
                <!-- Pressure Range Controls -->
                <div id="pressure-range-controls" style="margin-left: 20px;">
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; color: #cccccc; font-size: 11px; margin-bottom: 4px;">Min Pressure: <span id="min-pressure-value">10</span>%</label>
                        <input type="range" id="min-pressure" min="1" max="50" value="10" style="width: 100%; background: #3c3c3c;">
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; color: #cccccc; font-size: 11px; margin-bottom: 4px;">Max Pressure: <span id="max-pressure-value">100</span>%</label>
                        <input type="range" id="max-pressure" min="50" max="100" value="100" style="width: 100%; background: #3c3c3c;">
                    </div>
                    
                    <!-- Mouse Speed Simulation -->
                    <div style="margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; color: #cccccc; font-size: 11px; margin-bottom: 4px;">
                            <input type="checkbox" id="mouse-speed-pressure" checked style="margin-right: 6px;">
                            Mouse Speed Simulation
                        </label>
                        <div style="font-size: 9px; color: #999;">Simulate pressure based on drawing speed</div>
                    </div>
                    
                    <!-- Real-time Feedback -->
                    <div style="margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; color: #cccccc; font-size: 11px;">
                            <input type="checkbox" id="pressure-feedback" checked style="margin-right: 6px;">
                            Real-time Feedback
                        </label>
                        <div style="font-size: 9px; color: #999;">Show pressure indicator and cursor</div>
                    </div>
                </div>
                
                <div style="font-size: 10px; color: #999; margin-top: 6px;">Works with pressure-sensitive stylus/tablet</div>
            </div>
            
            <!-- Smoothing -->
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Smoothing: <span id="smoothing-value">50</span>%</label>
                <input type="range" id="smoothing" min="0" max="100" value="50" style="width: 100%; background: #3c3c3c;">
            </div>
            
            <!-- Shape Fill Mode -->
            <div id="shape-fill-mode" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 8px;">Fill Mode</label>
                <div style="display: flex; gap: 5px;">
                    <button id="fill-outline" class="fill-mode-btn active" data-mode="outline" style="flex: 1; padding: 6px; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Outline</button>
                    <button id="fill-filled" class="fill-mode-btn" data-mode="filled" style="flex: 1; padding: 6px; background: #3c3c3c; color: #cccccc; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Filled</button>
                    <button id="fill-both" class="fill-mode-btn" data-mode="both" style="flex: 1; padding: 6px; background: #3c3c3c; color: #cccccc; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Both</button>
                </div>
            </div>
            
            <!-- Stroke Color (for shapes) -->
            <div id="stroke-color-section" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Stroke Color</label>
                <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                    <input type="color" id="stroke-color-picker" value="#000000" style="width: 40px; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                    <button class="stroke-color-preset" data-color="#000000" style="width: 25px; height: 25px; background: #000000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#ff0000" style="width: 25px; height: 25px; background: #ff0000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#00ff00" style="width: 25px; height: 25px; background: #00ff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#0000ff" style="width: 25px; height: 25px; background: #0000ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#ffff00" style="width: 25px; height: 25px; background: #ffff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#ff00ff" style="width: 25px; height: 25px; background: #ff00ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#00ffff" style="width: 25px; height: 25px; background: #00ffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="stroke-color-preset" data-color="#ffffff" style="width: 25px; height: 25px; background: #ffffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                </div>
            </div>
            
            <!-- Fill Color (shown when fill mode is not outline) -->
            <div id="fill-color-section" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Fill Color</label>
                <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                    <input type="color" id="fill-color-picker" value="#000000" style="width: 40px; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                    <button class="fill-color-preset" data-color="#000000" style="width: 25px; height: 25px; background: #000000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#ff0000" style="width: 25px; height: 25px; background: #ff0000; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#00ff00" style="width: 25px; height: 25px; background: #00ff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#0000ff" style="width: 25px; height: 25px; background: #0000ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#ffff00" style="width: 25px; height: 25px; background: #ffff00; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#ff00ff" style="width: 25px; height: 25px; background: #ff00ff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#00ffff" style="width: 25px; height: 25px; background: #00ffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                    <button class="fill-color-preset" data-color="#ffffff" style="width: 25px; height: 25px; background: #ffffff; border: 1px solid #555; border-radius: 3px; cursor: pointer;"></button>
                </div>
            </div>
            
            <!-- Corner Radius (for rectangles) -->
            <div id="corner-radius-section" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Corner Radius: <span id="corner-radius-value">0</span>px</label>
                <input type="range" id="corner-radius" min="0" max="50" value="0" style="width: 100%; background: #3c3c3c;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: #999; margin-top: 2px;">
                    <span>0px</span>
                    <span>50px</span>
                </div>
            </div>
            
            <!-- Ellipse Aspect Ratio (for circles/ellipses) -->
            <div id="ellipse-aspect-section" style="margin-bottom: 15px; display: none;">
                <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 8px;">Ellipse Mode</label>
                <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                    <button id="ellipse-circle" class="ellipse-mode-btn active" data-mode="circle" style="flex: 1; padding: 6px; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Circle</button>
                    <button id="ellipse-free" class="ellipse-mode-btn" data-mode="free" style="flex: 1; padding: 6px; background: #3c3c3c; color: #cccccc; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Free Ellipse</button>
                </div>
                <div id="aspect-ratio-controls" style="display: none;">
                    <label style="display: block; color: #cccccc; font-size: 12px; margin-bottom: 5px;">Aspect Ratio: <span id="aspect-ratio-value">1.0</span></label>
                    <input type="range" id="aspect-ratio" min="0.2" max="5.0" step="0.1" value="1.0" style="width: 100%; background: #3c3c3c;">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #999; margin-top: 2px;">
                        <span>0.2 (tall)</span>
                        <span>5.0 (wide)</span>
                    </div>
                </div>
            </div>
        </div>
        
        <canvas id="drawing-canvas"></canvas>
        
        <!-- Pressure Sensitivity Indicator -->
        <div id="pressure-indicator" style="display: none; position: absolute; bottom: 20px; left: 20px; width: 200px; background: rgba(30, 30, 30, 0.9); border: 1px solid #555; border-radius: 6px; padding: 10px; z-index: 200;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #cccccc; font-size: 12px; font-weight: 500;">Pressure</span>
                <span id="pressure-value" style="color: #cccccc; font-size: 12px;">50%</span>
            </div>
            <div style="width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden;">
                <div class="pressure-bar" style="height: 100%; width: 50%; background: #28a745; transition: width 0.1s ease, background-color 0.1s ease;"></div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px;">
                <span class="device-label" style="color: #999; font-size: 10px;">Mouse (Speed)</span>
                <span style="color: #999; font-size: 10px;">Real-time</span>
            </div>
        </div>
        
        <!-- Code Generation Panel -->
        <div id="code-panel" style="display: none; position: absolute; right: 10px; top: 50px; width: 300px; max-height: 400px; background: rgba(30, 30, 30, 0.95); border: 1px solid #555; border-radius: 8px; padding: 10px; z-index: 200;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; color: #cccccc; font-size: 14px;">Generated Code</h3>
                <button id="close-code-panel" style="background: none; border: none; color: #999; cursor: pointer; font-size: 16px;">✕</button>
            </div>
            <select id="code-language" style="width: 100%; margin-bottom: 10px; background: #3c3c3c; color: #cccccc; border: 1px solid #555; padding: 5px;">
                <option value="html">HTML Canvas</option>
                <option value="svg">SVG</option>
                <option value="css">CSS</option>
                <option value="javascript">JavaScript</option>
            </select>
            <textarea id="code-output" readonly style="width: 100%; height: 250px; background: #1a1a1a; color: #cccccc; border: 1px solid #555; padding: 8px; font-family: 'Courier New', monospace; font-size: 12px; resize: vertical;"></textarea>
            <div style="margin-top: 10px;">
                <button id="copy-code" style="background: #007acc; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">Copy Code</button>
                <button id="refresh-code" style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-left: 5px;">Refresh</button>
            </div>
        </div>
    </div>

    <!-- Error Recovery Manager and Notification System are loaded inline to avoid CSP issues -->
    
    <!-- Load persistent drawing manager -->
    <script src="persistent-drawing-manager.js"></script>
    
    <!-- Load tool state manager -->
    <script src="tool-state-manager.js"></script>
    
    <!-- Load pressure sensitivity manager -->
    <script src="pressure-sensitivity.js"></script>
    
    <!-- Load enhanced tool manager -->
    <script src="enhanced-tool-manager.js"></script>
    
    <!-- Load safe code generation system -->
    <script src="safe-code-generator.js"></script>
    <script src="safe-template-system.js"></script>
    <script src="code-generation-error-handler.js"></script>
    
    <!-- Load tool integration -->
    <script src="tool-integration.js"></script>
    
    <script>
        // Simple inline error recovery system to avoid external script CSP issues
        (function() {
            'use strict';
            
            // Simple error recovery for VS Code API issues
            window.handleVsCodeApiError = function(error) {
                console.log('Handling VS Code API error:', error.message);
                
                // If the error is about API already being acquired, use existing instance
                if (error.message.includes('already been acquired') && window.vscodeApi) {
                    console.log('Using existing VS Code API instance');
                    if (window.VSSCanvas) {
                        window.VSSCanvas.vscode = window.vscodeApi;
                    }
                    return true;
                }
                
                return false;
            };
            
            // Enhanced error notification system
            window.ErrorNotificationSystem = function() {
                this.showEnhancedError = function(errorType, error, options = {}) {
                    console.log(`Enhanced error notification: ${errorType}`, error.message);
                    
                    // Try to handle VS Code API errors automatically
                    if (errorType === 'VSCODE_API_ERROR' || error.message.includes('already been acquired')) {
                        const handled = window.handleVsCodeApiError(error);
                        if (handled) {
                            console.log('VS Code API error handled automatically');
                            return;
                        }
                    }
                    
                    // Fall back to standard error display
                    if (window.showError) {
                        window.showError(error.message, error.stack);
                    }
                };
            };
            
            console.log('Inline error recovery system loaded');
        })();
    </script>
    
    <script>
        // IIFE wrapper to create local scope and prevent variable conflicts
        (function() {
            'use strict';
            
            console.log('VSSCanvas: Starting initialization check...');
            
            // Check for existing VSSCanvas instance and cleanup if needed
            if (typeof window.VSSCanvas !== 'undefined') {
                console.log('VSSCanvas: Existing instance detected');
                
                if (window.VSSCanvas.initialized) {
                    console.log('VSSCanvas: Previous instance was initialized, cleaning up...');
                    try {
                        window.VSSCanvas.cleanup();
                    } catch (cleanupError) {
                        console.warn('VSSCanvas: Error during cleanup of previous instance:', cleanupError);
                        // Continue with reinitialization even if cleanup fails
                    }
                } else {
                    console.log('VSSCanvas: Previous instance was not initialized, proceeding with setup...');
                }
            } else {
                console.log('VSSCanvas: No existing instance found, creating new namespace...');
            }
            
            // Create or reset VSSCanvas namespace to encapsulate all variables and functions
            window.VSSCanvas = {
                // Canvas and drawing state variables
                canvas: null,
                ctx: null,
                isDrawing: false,
                currentTool: 'pen',
                lastX: 0,
                lastY: 0,
                hasInitialized: false,
                initializationTimeout: null,
                
                // Connection monitoring variables
                connectionCheckInterval: null,
                lastMessageTime: Date.now(),
                
                // DOM element references
                loadingScreen: null,
                errorScreen: null,
                loadingStatus: null,
                
                // VS Code API reference
                vscode: null,
                
                // Initialization flag
                initialized: false,
                
                // Instance creation timestamp for debugging
                createdAt: new Date().toISOString(),
                
                // Instance ID for debugging reinitialization scenarios
                instanceId: Math.random().toString(36).substr(2, 9)
            };
            
            console.log('VSSCanvas: Namespace created/reset with instance ID:', window.VSSCanvas.instanceId);
            
            // Enhanced drawing state
            window.VSSCanvas.drawingElements = []; // Store drawn elements for code generation
            window.VSSCanvas.currentShape = null; // For shape tools
            window.VSSCanvas.isDrawingShape = false;
            window.VSSCanvas.startX = 0;
            window.VSSCanvas.startY = 0;
            
            // Drawing settings
            window.VSSCanvas.settings = {
                strokeSize: 5,
                opacity: 1.0,
                color: '#000000',
                fillColor: '#000000',
                fillMode: 'outline', // 'outline', 'filled', 'both'
                cornerRadius: 0,
                ellipseMode: 'circle', // 'circle', 'free'
                aspectRatio: 1.0,
                pressureSensitivity: true,
                smoothing: 0.5,
                minPressure: 0.1,
                maxPressure: 1.0,
                mouseSpeedPressure: true,
                pressureFeedback: true
            };
            
            // Pressure and smoothing state
            window.VSSCanvas.pressurePoints = [];
            window.VSSCanvas.smoothedPath = [];
            
            // Add init method to VSSCanvas namespace
            window.VSSCanvas.init = function() {
                console.log('VSSCanvas: Starting initialization for instance ID:', this.instanceId);
                
                try {
                    updateLoadingStatus('Initializing canvas...');
                    initializeCanvas();
                    
                    updateLoadingStatus('Setting up drawing tools...');
                    setupEventListeners();
                    
                    updateLoadingStatus('Establishing connection...');
                    setupMessagePassing();
                    
                    updateLoadingStatus('Canvas ready!');
                    this.initialized = true;
                    
                    // Hide loading screen after a short delay
                    setTimeout(function() {
                        if (window.VSSCanvas.initializationTimeout) {
                            clearTimeout(window.VSSCanvas.initializationTimeout);
                            window.VSSCanvas.initializationTimeout = null;
                        }
                        hideLoadingScreen();
                    }, 500);
                    
                    console.log('VSSCanvas: Initialization completed successfully');
                    return true;
                    
                } catch (error) {
                    console.error('VSSCanvas: Initialization failed:', error);
                    showError('Initialization failed: ' + error.message, error.stack);
                    return false;
                }
            };
            
            // Add cleanup method to VSSCanvas namespace
            window.VSSCanvas.cleanup = function() {
                console.log('VSSCanvas: Cleaning up instance ID:', this.instanceId);
                
                // Clear timeouts
                if (this.initializationTimeout) {
                    clearTimeout(this.initializationTimeout);
                    this.initializationTimeout = null;
                }
                
                if (this.connectionCheckInterval) {
                    clearInterval(this.connectionCheckInterval);
                    this.connectionCheckInterval = null;
                }
                
                // Reset state
                this.initialized = false;
                this.hasInitialized = false;
                this.canvas = null;
                this.ctx = null;
                this.isDrawing = false;
                
                console.log('VSSCanvas: Cleanup completed for instance ID:', this.instanceId);
            };
            
            // Get VS Code API for message passing with singleton pattern
            try {
                // Check if VS Code API was already acquired globally
                if (!window.vscodeApi && typeof acquireVsCodeApi === 'function') {
                    window.vscodeApi = acquireVsCodeApi();
                    console.log('VSSCanvas: VS Code API acquired successfully');
                } else if (window.vscodeApi) {
                    console.log('VSSCanvas: Using existing VS Code API instance');
                } else {
                    console.warn('VSSCanvas: acquireVsCodeApi function not available');
                }
                
                // Always use the global instance
                window.VSSCanvas.vscode = window.vscodeApi || null;
                
            } catch (apiError) {
                console.error('VSSCanvas: Error acquiring VS Code API:', apiError);
                
                // Try to handle VS Code API error automatically
                if (window.handleVsCodeApiError && window.handleVsCodeApiError(apiError)) {
                    console.log('VSSCanvas: VS Code API error handled, continuing with existing instance');
                    window.VSSCanvas.vscode = window.vscodeApi || null;
                } else {
                    console.warn('VSSCanvas: Could not recover from VS Code API error, continuing without API');
                    window.VSSCanvas.vscode = null;
                }
            }
        
        // Initialize DOM element references in namespace with existence checks
        function initializeDOMReferences() {
            console.log('VSSCanvas: Initializing DOM element references...');
            
            window.VSSCanvas.loadingScreen = document.getElementById('loading-screen');
            if (!window.VSSCanvas.loadingScreen) {
                console.warn('VSSCanvas: Loading screen element not found');
            }
            
            window.VSSCanvas.errorScreen = document.getElementById('error-screen');
            if (!window.VSSCanvas.errorScreen) {
                console.warn('VSSCanvas: Error screen element not found');
            }
            
            window.VSSCanvas.loadingStatus = document.getElementById('loading-status');
            if (!window.VSSCanvas.loadingStatus) {
                console.warn('VSSCanvas: Loading status element not found');
            }
            
            console.log('VSSCanvas: DOM references initialized');
        }
        
        // Initialize DOM references
        initializeDOMReferences();
        
        // Enhanced Drawing Tools Implementation
        window.VSSCanvas.tools = {
            pen: {
                start: function(x, y, pressure = 0.5) {
                    window.VSSCanvas.ctx.beginPath();
                    window.VSSCanvas.ctx.moveTo(x, y);
                    window.VSSCanvas.ctx.lineCap = 'round';
                    window.VSSCanvas.ctx.lineJoin = 'round';
                    
                    // Apply settings
                    const baseSize = window.VSSCanvas.settings.strokeSize;
                    const pressureMultiplier = window.VSSCanvas.settings.pressureSensitivity ? 
                        (pressure * 0.8 + 0.2) : 1.0; // 20% minimum, 100% maximum
                    
                    window.VSSCanvas.ctx.lineWidth = baseSize * pressureMultiplier;
                    window.VSSCanvas.ctx.strokeStyle = window.VSSCanvas.settings.color;
                    window.VSSCanvas.ctx.globalAlpha = window.VSSCanvas.settings.opacity;
                    
                    // Initialize smoothing
                    window.VSSCanvas.smoothedPath = [{x, y, pressure}];
                },
                draw: function(x, y, pressure = 0.5) {
                    if (window.VSSCanvas.settings.smoothing > 0) {
                        // Add point to smoothed path
                        window.VSSCanvas.smoothedPath.push({x, y, pressure});
                        
                        // Apply smoothing
                        if (window.VSSCanvas.smoothedPath.length >= 3) {
                            const smoothed = applySmoothingFilter(window.VSSCanvas.smoothedPath);
                            drawSmoothLine(smoothed);
                        }
                    } else {
                        // Direct drawing without smoothing
                        const baseSize = window.VSSCanvas.settings.strokeSize;
                        const pressureMultiplier = window.VSSCanvas.settings.pressureSensitivity ? 
                            (pressure * 0.8 + 0.2) : 1.0;
                        
                        window.VSSCanvas.ctx.lineWidth = baseSize * pressureMultiplier;
                        window.VSSCanvas.ctx.lineTo(x, y);
                        window.VSSCanvas.ctx.stroke();
                    }
                },
                end: function() {
                    window.VSSCanvas.ctx.globalAlpha = 1.0;
                    window.VSSCanvas.drawingElements.push({
                        type: 'freehand',
                        tool: 'pen',
                        color: window.VSSCanvas.settings.color,
                        width: window.VSSCanvas.settings.strokeSize,
                        opacity: window.VSSCanvas.settings.opacity,
                        timestamp: Date.now()
                    });
                    window.VSSCanvas.smoothedPath = [];
                }
            },
            
            rectangle: {
                start: function(x, y) {
                    window.VSSCanvas.startX = x;
                    window.VSSCanvas.startY = y;
                    window.VSSCanvas.isDrawingShape = true;
                },
                draw: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    // Clear and redraw
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                    
                    // Draw preview rectangle
                    window.VSSCanvas.ctx.strokeStyle = '#007acc';
                    window.VSSCanvas.ctx.lineWidth = 2;
                    window.VSSCanvas.ctx.strokeRect(
                        window.VSSCanvas.startX, 
                        window.VSSCanvas.startY, 
                        x - window.VSSCanvas.startX, 
                        y - window.VSSCanvas.startY
                    );
                },
                end: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    const rect = {
                        type: 'rectangle',
                        x: Math.min(window.VSSCanvas.startX, x),
                        y: Math.min(window.VSSCanvas.startY, y),
                        width: Math.abs(x - window.VSSCanvas.startX),
                        height: Math.abs(y - window.VSSCanvas.startY),
                        color: '#007acc',
                        lineWidth: 2,
                        timestamp: Date.now()
                    };
                    
                    window.VSSCanvas.drawingElements.push(rect);
                    window.VSSCanvas.isDrawingShape = false;
                    
                    // Redraw everything
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                }
            },
            
            circle: {
                start: function(x, y) {
                    window.VSSCanvas.startX = x;
                    window.VSSCanvas.startY = y;
                    window.VSSCanvas.isDrawingShape = true;
                },
                draw: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    const radius = Math.sqrt(Math.pow(x - window.VSSCanvas.startX, 2) + Math.pow(y - window.VSSCanvas.startY, 2));
                    
                    // Clear and redraw
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                    
                    // Draw preview circle
                    window.VSSCanvas.ctx.strokeStyle = '#28a745';
                    window.VSSCanvas.ctx.lineWidth = 2;
                    window.VSSCanvas.ctx.beginPath();
                    window.VSSCanvas.ctx.arc(window.VSSCanvas.startX, window.VSSCanvas.startY, radius, 0, 2 * Math.PI);
                    window.VSSCanvas.ctx.stroke();
                },
                end: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    const radius = Math.sqrt(Math.pow(x - window.VSSCanvas.startX, 2) + Math.pow(y - window.VSSCanvas.startY, 2));
                    
                    const circle = {
                        type: 'circle',
                        x: window.VSSCanvas.startX,
                        y: window.VSSCanvas.startY,
                        radius: radius,
                        color: '#28a745',
                        lineWidth: 2,
                        timestamp: Date.now()
                    };
                    
                    window.VSSCanvas.drawingElements.push(circle);
                    window.VSSCanvas.isDrawingShape = false;
                    
                    // Redraw everything
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                }
            },
            
            line: {
                start: function(x, y) {
                    window.VSSCanvas.startX = x;
                    window.VSSCanvas.startY = y;
                    window.VSSCanvas.isDrawingShape = true;
                },
                draw: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    // Clear and redraw
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                    
                    // Draw preview line
                    window.VSSCanvas.ctx.strokeStyle = '#dc3545';
                    window.VSSCanvas.ctx.lineWidth = 2;
                    window.VSSCanvas.ctx.beginPath();
                    window.VSSCanvas.ctx.moveTo(window.VSSCanvas.startX, window.VSSCanvas.startY);
                    window.VSSCanvas.ctx.lineTo(x, y);
                    window.VSSCanvas.ctx.stroke();
                },
                end: function(x, y) {
                    if (!window.VSSCanvas.isDrawingShape) return;
                    
                    const line = {
                        type: 'line',
                        startX: window.VSSCanvas.startX,
                        startY: window.VSSCanvas.startY,
                        endX: x,
                        endY: y,
                        color: '#dc3545',
                        lineWidth: 2,
                        timestamp: Date.now()
                    };
                    
                    window.VSSCanvas.drawingElements.push(line);
                    window.VSSCanvas.isDrawingShape = false;
                    
                    // Redraw everything
                    window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
                    redrawElements();
                }
            },
            
            eraser: {
                start: function(x, y) {
                    window.VSSCanvas.ctx.globalCompositeOperation = 'destination-out';
                    window.VSSCanvas.ctx.beginPath();
                    window.VSSCanvas.ctx.arc(x, y, 10, 0, 2 * Math.PI);
                    window.VSSCanvas.ctx.fill();
                },
                draw: function(x, y) {
                    window.VSSCanvas.ctx.globalCompositeOperation = 'destination-out';
                    window.VSSCanvas.ctx.beginPath();
                    window.VSSCanvas.ctx.arc(x, y, 10, 0, 2 * Math.PI);
                    window.VSSCanvas.ctx.fill();
                },
                end: function() {
                    window.VSSCanvas.ctx.globalCompositeOperation = 'source-over';
                }
            }
        };
        
        // Smoothing and pressure functions
        function applySmoothingFilter(points) {
            if (points.length < 3) return points;
            
            const smoothingFactor = window.VSSCanvas.settings.smoothing / 100;
            const smoothed = [points[0]]; // Keep first point
            
            for (let i = 1; i < points.length - 1; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                const next = points[i + 1];
                
                // Apply smoothing using weighted average
                const smoothedPoint = {
                    x: curr.x * (1 - smoothingFactor) + (prev.x + next.x) * smoothingFactor / 2,
                    y: curr.y * (1 - smoothingFactor) + (prev.y + next.y) * smoothingFactor / 2,
                    pressure: curr.pressure * (1 - smoothingFactor) + (prev.pressure + next.pressure) * smoothingFactor / 2
                };
                
                smoothed.push(smoothedPoint);
            }
            
            smoothed.push(points[points.length - 1]); // Keep last point
            return smoothed;
        }
        
        function drawSmoothLine(points) {
            if (points.length < 2) return;
            
            window.VSSCanvas.ctx.beginPath();
            window.VSSCanvas.ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                const point = points[i];
                
                // Apply pressure to line width
                if (window.VSSCanvas.settings.pressureSensitivity) {
                    const baseSize = window.VSSCanvas.settings.strokeSize;
                    const pressureMultiplier = point.pressure * 0.8 + 0.2;
                    window.VSSCanvas.ctx.lineWidth = baseSize * pressureMultiplier;
                }
                
                window.VSSCanvas.ctx.lineTo(point.x, point.y);
                window.VSSCanvas.ctx.stroke();
                
                // Start new path for next segment to apply new line width
                if (i < points.length - 1) {
                    window.VSSCanvas.ctx.beginPath();
                    window.VSSCanvas.ctx.moveTo(point.x, point.y);
                }
            }
        }
        
        function getPressureFromEvent(e) {
            // Try to get pressure from pointer event (stylus/tablet)
            if (e.pressure !== undefined) {
                return Math.max(e.pressure, window.VSSCanvas.settings.minPressure);
            }
            
            // Try to get pressure from touch event
            if (e.touches && e.touches[0] && e.touches[0].force !== undefined) {
                return Math.max(e.touches[0].force, window.VSSCanvas.settings.minPressure);
            }
            
            // Simulate pressure based on mouse velocity for mouse users
            if (e.type.includes('mouse')) {
                const now = Date.now();
                const timeDelta = now - (window.VSSCanvas.lastEventTime || now);
                const distance = Math.sqrt(
                    Math.pow(e.clientX - (window.VSSCanvas.lastMouseX || e.clientX), 2) +
                    Math.pow(e.clientY - (window.VSSCanvas.lastMouseY || e.clientY), 2)
                );
                
                window.VSSCanvas.lastEventTime = now;
                window.VSSCanvas.lastMouseX = e.clientX;
                window.VSSCanvas.lastMouseY = e.clientY;
                
                // Slower movement = higher pressure (more natural feel)
                const velocity = timeDelta > 0 ? distance / timeDelta : 0;
                const simulatedPressure = Math.max(0.3, Math.min(1.0, 1.0 - velocity * 0.1));
                return simulatedPressure;
            }
            
            return 0.5; // Default pressure
        }
        
        // Robust code generation function with error handling
        async function generateCode() {
            const language = document.getElementById('code-language')?.value || 'html';
            const codeOutput = document.getElementById('code-output');
            
            if (!codeOutput) {
                console.error('Code output element not found');
                return;
            }
            
            // Show loading state
            codeOutput.value = 'Generating code...';
            
            try {
                // Initialize error handler if not available
                if (!window.codeErrorHandler && window.CodeGenerationErrorHandler) {
                    window.codeErrorHandler = new window.CodeGenerationErrorHandler();
                }
                
                // Get drawing elements
                const elements = window.VSSCanvas?.enhancedToolManager?.getAllElements() || 
                               window.VSSCanvas?.drawingElements || [];
                
                // Get canvas dimensions
                const canvas = document.getElementById('drawing-canvas');
                const canvasWidth = canvas ? canvas.width : 800;
                const canvasHeight = canvas ? canvas.height : 600;
                
                // Generate code with error handling
                const result = await generateCodeWithErrorHandling(language, elements, canvasWidth, canvasHeight);
                
                if (result.success) {
                    codeOutput.value = result.result;
                    
                    // Show success message if recovered or using fallback
                    if (result.recovered || result.fallback) {
                        showCodeGenerationMessage(result.userMessage || 'Code generated with recovery', 'warning');
                    }
                } else {
                    codeOutput.value = `// Code generation failed: ${result.error.userMessage || result.error.message}`;
                    showCodeGenerationMessage(result.userMessage || 'Code generation failed', 'error');
                }
                
            } catch (error) {
                console.error('Code generation error:', error);
                codeOutput.value = `// Error: ${error.message}`;
                showCodeGenerationMessage('Code generation failed. Please try again.', 'error');
            }
        }
        
        // Generate code with comprehensive error handling
        async function generateCodeWithErrorHandling(outputType, elements, canvasWidth, canvasHeight) {
            // Use error handler if available
            if (window.codeErrorHandler) {
                const options = {
                    outputType: outputType,
                    canvasWidth: canvasWidth,
                    canvasHeight: canvasHeight,
                    timeout: 30000
                };
                
                let generatorFunction;
                switch (outputType) {
                    case 'html':
                        generatorFunction = (els, w, h) => new window.SafeCodeGenerator().generateHTML(els, w, h);
                        break;
                    case 'svg':
                        generatorFunction = (els, w, h) => new window.SafeCodeGenerator().generateSVG(els, w, h);
                        break;
                    case 'css':
                        generatorFunction = (els, w, h) => new window.SafeCodeGenerator().generateCSS(els);
                        break;
                    case 'javascript':
                        generatorFunction = (els, w, h) => new window.SafeCodeGenerator().generateJavaScript(els);
                        break;
                    default:
                        throw new Error(`Unknown output type: ${outputType}`);
                }
                
                return await window.codeErrorHandler.executeWithErrorHandling(generatorFunction, elements, options);
            }
            
            // Fallback to direct generation
            const generator = new window.SafeCodeGenerator();
            let result;
            
            switch (outputType) {
                case 'html':
                    result = generator.generateHTML(elements, canvasWidth, canvasHeight);
                    break;
                case 'svg':
                    result = generator.generateSVG(elements, canvasWidth, canvasHeight);
                    break;
                case 'css':
                    result = generator.generateCSS(elements);
                    break;
                case 'javascript':
                    result = generator.generateJavaScript(elements);
                    break;
                default:
                    throw new Error(`Unknown output type: ${outputType}`);
            }
            
            return { success: true, result: result };
        }
        
        // Show code generation messages to user
        function showCodeGenerationMessage(message, type = 'info') {
            // Create or update message element
            let messageEl = document.getElementById('code-generation-message');
            if (!messageEl) {
                messageEl = document.createElement('div');
                messageEl.id = 'code-generation-message';
                messageEl.style.cssText = `
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    padding: 8px 12px;
                    border-radius: 4px;
                    font-size: 12px;
                    z-index: 1000;
                    max-width: 300px;
                    word-wrap: break-word;
                `;
                
                const codePanel = document.getElementById('code-panel');
                if (codePanel) {
                    codePanel.appendChild(messageEl);
                }
            }
            
            // Set message and style based on type
            messageEl.textContent = message;
            switch (type) {
                case 'error':
                    messageEl.style.backgroundColor = '#d32f2f';
                    messageEl.style.color = 'white';
                    break;
                case 'warning':
                    messageEl.style.backgroundColor = '#f57c00';
                    messageEl.style.color = 'white';
                    break;
                case 'success':
                    messageEl.style.backgroundColor = '#388e3c';
                    messageEl.style.color = 'white';
                    break;
                default:
                    messageEl.style.backgroundColor = '#1976d2';
                    messageEl.style.color = 'white';
            }
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (messageEl && messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 5000);
        }
        
        function generateCanvasCommands() {
            return '// Canvas commands generation temporarily disabled';
        }
        
        // Function to redraw all elements
        function redrawElements() {
            window.VSSCanvas.drawingElements.forEach(element => {
                window.VSSCanvas.ctx.strokeStyle = element.color || '#000000';
                window.VSSCanvas.ctx.lineWidth = element.lineWidth || 2;
                
                switch (element.type) {
                    case 'rectangle':
                        window.VSSCanvas.ctx.strokeRect(element.x, element.y, element.width, element.height);
                        break;
                    case 'circle':
                        window.VSSCanvas.ctx.beginPath();
                        window.VSSCanvas.ctx.arc(element.x, element.y, element.radius, 0, 2 * Math.PI);
                        window.VSSCanvas.ctx.stroke();
                        break;
                    case 'line':
                        window.VSSCanvas.ctx.beginPath();
                        window.VSSCanvas.ctx.moveTo(element.startX, element.startY);
                        window.VSSCanvas.ctx.lineTo(element.endX, element.endY);
                        window.VSSCanvas.ctx.stroke();
                        break;
                }
            });
        }
        
        // Initialize error notification system
        if (window.ErrorNotificationSystem && !window.errorNotificationSystem) {
            window.errorNotificationSystem = new window.ErrorNotificationSystem();
            console.log('VSSCanvas: Error notification system initialized');
        }

        function updateLoadingStatus(message) {
            if (window.VSSCanvas.loadingStatus) {
                window.VSSCanvas.loadingStatus.textContent = message;
            }
            console.log('VSS Loading:', message);
        }

        function showError(message, stack) {
            console.error('VSSCanvas Error:', message, stack);
            
            // Check if error screen exists before trying to use it
            if (window.VSSCanvas.errorScreen) {
                const errorMessage = document.getElementById('error-message');
                const errorStackElement = document.getElementById('error-stack');
                
                if (errorMessage) {
                    errorMessage.textContent = message;
                } else {
                    console.warn('VSSCanvas: Error message element not found');
                }
                
                if (errorStackElement && stack) {
                    errorStackElement.textContent = stack;
                } else if (stack) {
                    console.warn('VSSCanvas: Error stack element not found');
                }
                
                window.VSSCanvas.errorScreen.style.display = 'flex';
            } else {
                console.warn('VSSCanvas: Error screen element not available, cannot display error UI');
                // Fallback: show alert if error screen is not available
                alert('Canvas Error: ' + message);
            }
            
            // Hide loading screen if it exists
            if (window.VSSCanvas.loadingScreen) {
                window.VSSCanvas.loadingScreen.style.display = 'none';
            }

            // Send error to extension if VS Code API is available
            if (window.VSSCanvas.vscode) {
                try {
                    window.VSSCanvas.vscode.postMessage({
                        command: 'error',
                        data: {
                            message: message,
                            stack: stack,
                            source: 'webview-initialization',
                            instanceId: window.VSSCanvas.instanceId
                        }
                    });
                } catch (postError) {
                    console.error('VSSCanvas: Failed to send error message to extension:', postError);
                }
            } else {
                console.warn('VSSCanvas: Cannot send error to extension - VS Code API not available');
            }
        }

        function hideLoadingScreen() {
            if (window.VSSCanvas.loadingScreen) {
                window.VSSCanvas.loadingScreen.style.display = 'none';
            }
            
            // Explicitly show the canvas container since CSS sibling selector still applies
            const canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer) {
                canvasContainer.style.display = 'flex';
                console.log('VSSCanvas: Canvas container shown');
            }
            
            // Ensure canvas is properly sized after showing container
            setTimeout(() => {
                resizeCanvas();
            }, 100);
            
            window.VSSCanvas.hasInitialized = true;
            
            // Send ready message to extension
            if (window.VSSCanvas.vscode) {
                window.VSSCanvas.vscode.postMessage({
                    command: 'canvasReady',
                    data: {
                        timestamp: new Date().toISOString(),
                        width: window.VSSCanvas.canvas ? window.VSSCanvas.canvas.width : 0,
                        height: window.VSSCanvas.canvas ? window.VSSCanvas.canvas.height : 0
                    }
                });
            }
        }
        
        // Initialize canvas when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            updateLoadingStatus('Loading components...');
            
            // Set initialization timeout in namespace
            window.VSSCanvas.initializationTimeout = setTimeout(function() {
                if (!window.VSSCanvas.hasInitialized) {
                    showError('Initialization timeout - Canvas failed to load within 10 seconds', null);
                }
            }, 10000);

            // Use VSSCanvas namespace initialization
            if (window.VSSCanvas) {
                window.VSSCanvas.init();
            } else {
                showError('VSSCanvas namespace not found', null);
            }
        });

        // Set up global error handlers
        window.addEventListener('error', function(e) {
            const error = e.error || new Error(e.message);
            
            // Check if this is a VS Code API error
            if (error.message && error.message.includes('already been acquired')) {
                console.log('Global error handler: VS Code API error detected');
                if (window.handleVsCodeApiError && window.handleVsCodeApiError(error)) {
                    console.log('Global error handler: VS Code API error handled');
                    return; // Don't show error screen if handled
                }
            }
            
            if (!window.VSSCanvas.hasInitialized) {
                // Use enhanced error notification system if available
                if (window.ErrorNotificationSystem) {
                    const notificationSystem = new window.ErrorNotificationSystem();
                    notificationSystem.showEnhancedError('UNKNOWN', error, {
                        filename: e.filename,
                        lineno: e.lineno,
                        colno: e.colno,
                        context: 'global_error_handler'
                    });
                } else {
                    // Fallback to basic error display
                    showError('Initialization Error: ' + e.message, error.stack);
                }
            } else {
                // Send to extension and show notification
                if (window.VSSCanvas.vscode) {
                    window.VSSCanvas.vscode.postMessage({
                        command: 'error',
                        data: {
                            message: e.message,
                            filename: e.filename,
                            lineno: e.lineno,
                            colno: e.colno,
                            stack: error.stack
                        }
                    });
                }
                
                // Show user-friendly notification
                if (window.ErrorNotificationSystem) {
                    const notificationSystem = new window.ErrorNotificationSystem();
                    notificationSystem.showEnhancedError('UNKNOWN', error, {
                        showNotification: true,
                        context: 'runtime_error'
                    });
                }
            }
        });

        window.addEventListener('unhandledrejection', function(e) {
            const error = e.reason instanceof Error ? e.reason : new Error(e.reason ? e.reason.toString() : 'Unknown promise rejection');
            
            // Check if this is a VS Code API error
            if (error.message && error.message.includes('already been acquired')) {
                console.log('Unhandled rejection: VS Code API error detected');
                if (window.handleVsCodeApiError && window.handleVsCodeApiError(error)) {
                    console.log('Unhandled rejection: VS Code API error handled');
                    return; // Don't show error screen if handled
                }
            }
            
            if (!window.VSSCanvas.hasInitialized) {
                // Use enhanced error notification system if available
                if (window.ErrorNotificationSystem) {
                    const notificationSystem = new window.ErrorNotificationSystem();
                    notificationSystem.showEnhancedError('UNKNOWN', error, {
                        context: 'unhandled_promise_rejection'
                    });
                } else {
                    // Fallback to basic error display
                    showError('Unhandled Promise Rejection: ' + error.message, error.stack);
                }
            } else {
                // Send to extension and show notification
                if (window.VSSCanvas.vscode) {
                    window.VSSCanvas.vscode.postMessage({
                        command: 'error',
                        data: {
                            message: error.message,
                            stack: error.stack,
                            type: 'unhandled_promise_rejection'
                        }
                    });
                }
                
                // Show user-friendly notification
                if (window.ErrorNotificationSystem) {
                    const notificationSystem = new window.ErrorNotificationSystem();
                    notificationSystem.showEnhancedError('UNKNOWN', error, {
                        showNotification: true,
                        context: 'unhandled_promise_rejection'
                    });
                }
            }
        });

        // Set up retry functionality
        document.addEventListener('DOMContentLoaded', function() {
            const retryButton = document.getElementById('retry-button');
            const reportButton = document.getElementById('report-button');
            
            if (retryButton) {
                retryButton.addEventListener('click', function() {
                    // Try to reinitialize first, fallback to reload
                    if (window.VSSCanvas && window.VSSCanvas.reinitialize) {
                        const success = window.VSSCanvas.reinitialize();
                        if (!success) {
                            location.reload();
                        }
                    } else {
                        location.reload();
                    }
                });
            }
            
            if (reportButton) {
                reportButton.addEventListener('click', function() {
                    if (window.VSSCanvas.vscode) {
                        window.VSSCanvas.vscode.postMessage({
                            command: 'reportIssue',
                            data: {
                                source: 'webview-error-screen'
                            }
                        });
                    }
                });
            }
        });
        
        function initializeCanvas() {
            console.log('VSSCanvas: Initializing canvas element...');
            
            // Check if canvas already exists and is valid
            if (window.VSSCanvas.canvas && window.VSSCanvas.ctx) {
                console.log('VSSCanvas: Canvas already initialized, checking validity...');
                
                // Verify the existing canvas is still in the DOM
                if (document.contains(window.VSSCanvas.canvas)) {
                    console.log('VSSCanvas: Existing canvas is valid, reusing...');
                    resizeCanvas();
                    return;
                } else {
                    console.log('VSSCanvas: Existing canvas is no longer in DOM, reinitializing...');
                    window.VSSCanvas.canvas = null;
                    window.VSSCanvas.ctx = null;
                }
            }
            
            // Get canvas element
            window.VSSCanvas.canvas = document.getElementById('drawing-canvas');
            if (!window.VSSCanvas.canvas) {
                throw new Error('Canvas element not found in DOM - ensure the HTML contains an element with id="drawing-canvas"');
            }
            
            console.log('VSSCanvas: Canvas element found, getting 2D context...');

            // Get 2D rendering context
            window.VSSCanvas.ctx = window.VSSCanvas.canvas.getContext('2d');
            if (!window.VSSCanvas.ctx) {
                throw new Error('Failed to get 2D rendering context from canvas - browser may not support canvas');
            }
            
            console.log('VSSCanvas: 2D context acquired, setting up canvas...');
            
            // Set canvas size to fill container
            resizeCanvas();
            
            // Set default drawing properties
            window.VSSCanvas.ctx.lineCap = 'round';
            window.VSSCanvas.ctx.lineJoin = 'round';
            window.VSSCanvas.ctx.strokeStyle = '#000000';
            window.VSSCanvas.ctx.lineWidth = 2;
            
            console.log('VSSCanvas: Canvas initialization completed');
            updateStatus('Canvas ready for drawing');
        }
        
        function resizeCanvas() {
            if (!window.VSSCanvas.canvas) {
                console.warn('VSSCanvas: Cannot resize canvas - canvas not initialized');
                return;
            }
            
            const container = document.getElementById('canvas-container');
            if (!container) {
                console.warn('VSSCanvas: Cannot resize canvas - container element not found');
                return;
            }
            
            const statusElement = document.getElementById('status');
            const statusHeight = statusElement ? statusElement.offsetHeight : 0;
            
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight - statusHeight;
            
            // Ensure we have valid dimensions (avoid 0x0 canvas)
            const finalWidth = Math.max(newWidth, 300);
            const finalHeight = Math.max(newHeight, 200);
            
            // Get device pixel ratio for high DPI displays
            const dpr = window.devicePixelRatio || 1;
            
            // Only resize if dimensions have changed to avoid unnecessary redraws
            if (window.VSSCanvas.canvas.width !== finalWidth * dpr || window.VSSCanvas.canvas.height !== finalHeight * dpr) {
                console.log(`VSSCanvas: Resizing canvas from ${window.VSSCanvas.canvas.width}x${window.VSSCanvas.canvas.height} to ${finalWidth * dpr}x${finalHeight * dpr} (container: ${newWidth}x${newHeight}, DPR: ${dpr})`);
                
                // Set actual canvas size in memory (scaled for high DPI)
                window.VSSCanvas.canvas.width = finalWidth * dpr;
                window.VSSCanvas.canvas.height = finalHeight * dpr;
                
                // Set display size (CSS pixels)
                window.VSSCanvas.canvas.style.width = finalWidth + 'px';
                window.VSSCanvas.canvas.style.height = finalHeight + 'px';
                
                // Scale the drawing context to match device pixel ratio
                window.VSSCanvas.ctx.scale(dpr, dpr);
                
                // Restore drawing properties after resize (they get reset when canvas dimensions change)
                if (window.VSSCanvas.ctx) {
                    window.VSSCanvas.ctx.lineCap = 'round';
                    window.VSSCanvas.ctx.lineJoin = 'round';
                    window.VSSCanvas.ctx.strokeStyle = '#000000';
                    window.VSSCanvas.ctx.lineWidth = 2;
                }
            }
        }
        
        function setupEventListeners() {
            console.log('VSSCanvas: Setting up event listeners...');
            
            // Window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Tool buttons with existence check
            const toolButtons = document.querySelectorAll('.tool-button[data-tool]');
            if (toolButtons.length > 0) {
                toolButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        selectTool(this.dataset.tool);
                    });
                });
                console.log(`VSSCanvas: Added event listeners to ${toolButtons.length} tool buttons`);
            } else {
                console.warn('VSSCanvas: No tool buttons found');
            }
            
            // Clear canvas button with existence check
            const clearButton = document.getElementById('clear-canvas');
            if (clearButton) {
                clearButton.addEventListener('click', clearCanvas);
                console.log('VSSCanvas: Added event listener to clear button');
            } else {
                console.warn('VSSCanvas: Clear canvas button not found');
            }
            
            // Canvas drawing events with existence check
            if (window.VSSCanvas.canvas) {
                // Mouse events for drawing
                window.VSSCanvas.canvas.addEventListener('mousedown', startDrawing);
                window.VSSCanvas.canvas.addEventListener('mousemove', draw);
                window.VSSCanvas.canvas.addEventListener('mouseup', stopDrawing);
                window.VSSCanvas.canvas.addEventListener('mouseout', stopDrawing);
                
                // Touch events for mobile/tablet support
                window.VSSCanvas.canvas.addEventListener('touchstart', handleTouch);
                window.VSSCanvas.canvas.addEventListener('touchmove', handleTouch);
                window.VSSCanvas.canvas.addEventListener('touchend', stopDrawing);
                
                console.log('VSSCanvas: Added drawing event listeners to canvas');
            } else {
                console.error('VSSCanvas: Cannot add drawing event listeners - canvas not initialized');
                throw new Error('Canvas not initialized before setting up event listeners');
            }
            
            // Settings panel event listeners
            const settingsToggle = document.getElementById('settings-toggle');
            const settingsPanel = document.getElementById('settings-panel');
            const closeSettings = document.getElementById('close-settings');
            
            if (settingsToggle && settingsPanel) {
                settingsToggle.addEventListener('click', function() {
                    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
                });
            }
            
            if (closeSettings && settingsPanel) {
                closeSettings.addEventListener('click', function() {
                    settingsPanel.style.display = 'none';
                });
            }
            
            // Stroke size control
            const strokeSizeSlider = document.getElementById('stroke-size');
            const strokeSizeValue = document.getElementById('stroke-size-value');
            if (strokeSizeSlider && strokeSizeValue) {
                strokeSizeSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.strokeSize = parseInt(this.value);
                    strokeSizeValue.textContent = this.value;
                });
            }
            
            // Opacity control
            const opacitySlider = document.getElementById('opacity');
            const opacityValue = document.getElementById('opacity-value');
            if (opacitySlider && opacityValue) {
                opacitySlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.opacity = parseInt(this.value) / 100;
                    opacityValue.textContent = this.value;
                });
            }
            
            // Color picker
            const colorPicker = document.getElementById('color-picker');
            if (colorPicker) {
                colorPicker.addEventListener('change', function() {
                    window.VSSCanvas.settings.color = this.value;
                });
            }
            
            // Color presets
            const colorPresets = document.querySelectorAll('.color-preset');
            colorPresets.forEach(preset => {
                preset.addEventListener('click', function() {
                    const color = this.dataset.color;
                    window.VSSCanvas.settings.color = color;
                    if (colorPicker) colorPicker.value = color;
                });
            });
            
            // Pressure sensitivity toggle
            const pressureSensitivity = document.getElementById('pressure-sensitivity');
            if (pressureSensitivity) {
                pressureSensitivity.addEventListener('change', function() {
                    window.VSSCanvas.settings.pressureSensitivity = this.checked;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setEnabled(this.checked);
                    }
                    
                    // Show/hide pressure range controls
                    const pressureRangeControls = document.getElementById('pressure-range-controls');
                    if (pressureRangeControls) {
                        pressureRangeControls.style.display = this.checked ? 'block' : 'none';
                    }
                });
            }
            
            // Min pressure control
            const minPressureSlider = document.getElementById('min-pressure');
            const minPressureValue = document.getElementById('min-pressure-value');
            if (minPressureSlider && minPressureValue) {
                minPressureSlider.addEventListener('input', function() {
                    const minValue = parseInt(this.value);
                    window.VSSCanvas.settings.minPressure = minValue / 100;
                    minPressureValue.textContent = minValue;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setPressureRange(
                            window.VSSCanvas.settings.minPressure,
                            window.VSSCanvas.settings.maxPressure
                        );
                    }
                    
                    // Ensure min doesn't exceed max
                    const maxPressureSlider = document.getElementById('max-pressure');
                    if (maxPressureSlider && minValue >= parseInt(maxPressureSlider.value)) {
                        maxPressureSlider.value = minValue + 10;
                        const maxPressureValue = document.getElementById('max-pressure-value');
                        if (maxPressureValue) {
                            maxPressureValue.textContent = maxPressureSlider.value;
                            window.VSSCanvas.settings.maxPressure = parseInt(maxPressureSlider.value) / 100;
                        }
                    }
                });
            }
            
            // Max pressure control
            const maxPressureSlider = document.getElementById('max-pressure');
            const maxPressureValue = document.getElementById('max-pressure-value');
            if (maxPressureSlider && maxPressureValue) {
                maxPressureSlider.addEventListener('input', function() {
                    const maxValue = parseInt(this.value);
                    window.VSSCanvas.settings.maxPressure = maxValue / 100;
                    maxPressureValue.textContent = maxValue;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setPressureRange(
                            window.VSSCanvas.settings.minPressure,
                            window.VSSCanvas.settings.maxPressure
                        );
                    }
                    
                    // Ensure max doesn't go below min
                    const minPressureSlider = document.getElementById('min-pressure');
                    if (minPressureSlider && maxValue <= parseInt(minPressureSlider.value)) {
                        minPressureSlider.value = maxValue - 10;
                        const minPressureValue = document.getElementById('min-pressure-value');
                        if (minPressureValue) {
                            minPressureValue.textContent = minPressureSlider.value;
                            window.VSSCanvas.settings.minPressure = parseInt(minPressureSlider.value) / 100;
                        }
                    }
                });
            }
            
            // Mouse speed pressure toggle
            const mouseSpeedPressure = document.getElementById('mouse-speed-pressure');
            if (mouseSpeedPressure) {
                mouseSpeedPressure.addEventListener('change', function() {
                    window.VSSCanvas.settings.mouseSpeedPressure = this.checked;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setMouseSpeedPressure(this.checked);
                    }
                });
            }
            
            // Pressure feedback toggle
            const pressureFeedback = document.getElementById('pressure-feedback');
            if (pressureFeedback) {
                pressureFeedback.addEventListener('change', function() {
                    window.VSSCanvas.settings.pressureFeedback = this.checked;
                    
                    // Update pressure sensitivity manager
                    if (window.pressureSensitivityManager) {
                        window.pressureSensitivityManager.setFeedbackEnabled(this.checked);
                    }
                });
            }
            
            // Initialize pressure controls visibility and values
            function initializePressureControls() {
                // Set initial visibility of pressure range controls
                const pressureRangeControls = document.getElementById('pressure-range-controls');
                const pressureSensitivityCheckbox = document.getElementById('pressure-sensitivity');
                
                if (pressureRangeControls && pressureSensitivityCheckbox) {
                    pressureRangeControls.style.display = pressureSensitivityCheckbox.checked ? 'block' : 'none';
                }
                
                // Set initial values from settings
                if (minPressureSlider && minPressureValue) {
                    minPressureSlider.value = window.VSSCanvas.settings.minPressure * 100;
                    minPressureValue.textContent = Math.round(window.VSSCanvas.settings.minPressure * 100);
                }
                
                if (maxPressureSlider && maxPressureValue) {
                    maxPressureSlider.value = window.VSSCanvas.settings.maxPressure * 100;
                    maxPressureValue.textContent = Math.round(window.VSSCanvas.settings.maxPressure * 100);
                }
                
                if (mouseSpeedPressure) {
                    mouseSpeedPressure.checked = window.VSSCanvas.settings.mouseSpeedPressure;
                }
                
                if (pressureFeedback) {
                    pressureFeedback.checked = window.VSSCanvas.settings.pressureFeedback;
                }
                
                console.log('Pressure controls initialized');
            }
            
            // Call initialization
            initializePressureControls();
            
            // Smoothing control
            const smoothingSlider = document.getElementById('smoothing');
            const smoothingValue = document.getElementById('smoothing-value');
            if (smoothingSlider && smoothingValue) {
                smoothingSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.smoothing = parseInt(this.value);
                    smoothingValue.textContent = this.value;
                });
            }
            
            // Fill mode buttons
            const fillModeButtons = document.querySelectorAll('.fill-mode-btn');
            fillModeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Update active state
                    fillModeButtons.forEach(btn => {
                        btn.classList.remove('active');
                        btn.style.background = '#3c3c3c';
                        btn.style.color = '#cccccc';
                    });
                    this.classList.add('active');
                    this.style.background = '#007acc';
                    this.style.color = 'white';
                    
                    // Update setting
                    window.VSSCanvas.settings.fillMode = this.dataset.mode;
                    
                    // Show/hide fill color section
                    const fillColorSection = document.getElementById('fill-color-section');
                    if (fillColorSection) {
                        fillColorSection.style.display = 
                            (this.dataset.mode === 'outline') ? 'none' : 'block';
                    }
                });
            });
            
            // Fill color picker
            const fillColorPicker = document.getElementById('fill-color-picker');
            if (fillColorPicker) {
                fillColorPicker.addEventListener('change', function() {
                    window.VSSCanvas.settings.fillColor = this.value;
                });
            }
            
            // Fill color presets
            const fillColorPresets = document.querySelectorAll('.fill-color-preset');
            fillColorPresets.forEach(preset => {
                preset.addEventListener('click', function() {
                    const color = this.dataset.color;
                    window.VSSCanvas.settings.fillColor = color;
                    if (fillColorPicker) fillColorPicker.value = color;
                });
            });
            
            // Corner radius control
            const cornerRadiusSlider = document.getElementById('corner-radius');
            const cornerRadiusValue = document.getElementById('corner-radius-value');
            if (cornerRadiusSlider && cornerRadiusValue) {
                cornerRadiusSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.cornerRadius = parseInt(this.value);
                    cornerRadiusValue.textContent = this.value;
                });
            }
            
            // Ellipse mode buttons
            const ellipseModeButtons = document.querySelectorAll('.ellipse-mode-btn');
            ellipseModeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Update active state
                    ellipseModeButtons.forEach(btn => {
                        btn.classList.remove('active');
                        btn.style.background = '#3c3c3c';
                        btn.style.color = '#cccccc';
                    });
                    this.classList.add('active');
                    this.style.background = '#007acc';
                    this.style.color = 'white';
                    
                    // Update setting
                    window.VSSCanvas.settings.ellipseMode = this.dataset.mode;
                    
                    // Show/hide aspect ratio controls
                    const aspectRatioControls = document.getElementById('aspect-ratio-controls');
                    if (aspectRatioControls) {
                        aspectRatioControls.style.display = 
                            (this.dataset.mode === 'free') ? 'block' : 'none';
                    }
                });
            });
            
            // Aspect ratio control
            const aspectRatioSlider = document.getElementById('aspect-ratio');
            const aspectRatioValue = document.getElementById('aspect-ratio-value');
            if (aspectRatioSlider && aspectRatioValue) {
                aspectRatioSlider.addEventListener('input', function() {
                    window.VSSCanvas.settings.aspectRatio = parseFloat(this.value);
                    aspectRatioValue.textContent = parseFloat(this.value).toFixed(1);
                });
            }
            
            // Generate code button
            const generateCodeBtn = document.getElementById('generate-code');
            const codePanel = document.getElementById('code-panel');
            if (generateCodeBtn && codePanel) {
                generateCodeBtn.addEventListener('click', function() {
                    generateCode();
                    codePanel.style.display = codePanel.style.display === 'none' ? 'block' : 'none';
                });
            }
            
            // Close code panel
            const closeCodePanel = document.getElementById('close-code-panel');
            if (closeCodePanel && codePanel) {
                closeCodePanel.addEventListener('click', function() {
                    codePanel.style.display = 'none';
                });
            }
            
            // Copy code functionality
            const copyCodeBtn = document.getElementById('copy-code');
            const refreshCodeBtn = document.getElementById('refresh-code');
            const codeOutput = document.getElementById('code-output');
            
            if (copyCodeBtn && codeOutput) {
                copyCodeBtn.addEventListener('click', function() {
                    codeOutput.select();
                    document.execCommand('copy');
                    
                    // Visual feedback
                    const originalText = this.textContent;
                    this.textContent = 'Copied!';
                    this.style.background = '#28a745';
                    
                    setTimeout(() => {
                        this.textContent = originalText;
                        this.style.background = '#007acc';
                    }, 1000);
                });
            }
            
            if (refreshCodeBtn) {
                refreshCodeBtn.addEventListener('click', function() {
                    generateCode();
                });
            }
            
            // Language selector change
            const languageSelector = document.getElementById('code-language');
            if (languageSelector) {
                languageSelector.addEventListener('change', function() {
                    generateCode();
                });
            }
            
            console.log('VSSCanvas: Event listeners setup completed');
        }
        
        function setupMessagePassing() {
            // Listen for messages from VS Code extension
            window.addEventListener('message', event => {
                const message = event.data;
                
                switch (message.command) {
                    case 'clearCanvas':
                        clearCanvas();
                        break;
                    case 'setTool':
                        selectTool(message.tool);
                        break;
                    case 'connectionStatus':
                        updateConnectionStatus(message.connected);
                        break;
                    default:
                        console.log('Unknown message:', message);
                }
            });
            
            // Send initial ready message to extension
            sendMessage({
                command: 'canvasReady',
                data: {
                    width: window.VSSCanvas.canvas.width,
                    height: window.VSSCanvas.canvas.height
                }
            });
        }
        
        function sendMessage(message) {
            try {
                // Check if VS Code API is available
                if (!window.VSSCanvas.vscode) {
                    console.warn('VSSCanvas: VS Code API not available, cannot send message:', message);
                    return false;
                }
                
                window.VSSCanvas.vscode.postMessage(message);
                return true;
            } catch (error) {
                console.error('VSSCanvas: Error sending message to extension:', error);
                updateStatus('Communication error with extension');
                
                // If we're not initialized yet, show error screen
                if (!window.VSSCanvas.hasInitialized) {
                    showError('Failed to communicate with VS Code extension: ' + error.message, error.stack);
                }
                return false;
            }
        }
        
        function selectTool(tool) {
            window.VSSCanvas.currentTool = tool;
            
            // Update button states
            document.querySelectorAll('.tool-button[data-tool]').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            // Update cursor
            window.VSSCanvas.canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
            
            // Show/hide shape-specific settings
            updateShapeSettings(tool);
            
            updateStatus(`Selected tool: ${tool}`);
            
            // Notify extension of tool change
            sendMessage({
                command: 'toolChanged',
                data: { tool: tool }
            });
        }
        
        function updateShapeSettings(tool) {
            const shapeFillMode = document.getElementById('shape-fill-mode');
            const fillColorSection = document.getElementById('fill-color-section');
            const cornerRadiusSection = document.getElementById('corner-radius-section');
            const ellipseAspectSection = document.getElementById('ellipse-aspect-section');
            
            // Hide all shape settings by default
            if (shapeFillMode) shapeFillMode.style.display = 'none';
            if (fillColorSection) fillColorSection.style.display = 'none';
            if (cornerRadiusSection) cornerRadiusSection.style.display = 'none';
            if (ellipseAspectSection) ellipseAspectSection.style.display = 'none';
            
            // Show relevant settings for shape tools
            if (tool === 'rectangle' || tool === 'circle' || tool === 'line') {
                if (shapeFillMode) shapeFillMode.style.display = 'block';
                
                // Show fill color if not in outline mode
                if (window.VSSCanvas.settings.fillMode !== 'outline' && fillColorSection) {
                    fillColorSection.style.display = 'block';
                }
                
                // Show corner radius only for rectangles
                if (tool === 'rectangle' && cornerRadiusSection) {
                    cornerRadiusSection.style.display = 'block';
                }
                
                // Show ellipse aspect controls only for circles
                if (tool === 'circle' && ellipseAspectSection) {
                    ellipseAspectSection.style.display = 'block';
                }
            }
        }
        
        function startDrawing(e) {
            window.VSSCanvas.isDrawing = true;
            [window.VSSCanvas.lastX, window.VSSCanvas.lastY] = getMousePos(e);
            
            // Get pressure information
            const pressure = getPressureFromEvent(e);
            
            // Use enhanced tools system
            if (window.VSSCanvas.tools && window.VSSCanvas.tools[window.VSSCanvas.currentTool]) {
                window.VSSCanvas.tools[window.VSSCanvas.currentTool].start(window.VSSCanvas.lastX, window.VSSCanvas.lastY, pressure);
            } else {
                // Fallback to basic drawing
                window.VSSCanvas.ctx.beginPath();
                window.VSSCanvas.ctx.moveTo(window.VSSCanvas.lastX, window.VSSCanvas.lastY);
            }
            
            sendMessage({
                command: 'drawingStarted',
                data: { 
                    tool: window.VSSCanvas.currentTool,
                    x: window.VSSCanvas.lastX, 
                    y: window.VSSCanvas.lastY,
                    pressure: pressure
                }
            });
        }
        
        function draw(e) {
            if (!window.VSSCanvas.isDrawing) return;
            
            const [currentX, currentY] = getMousePos(e);
            const pressure = getPressureFromEvent(e);
            
            // Use enhanced tools system
            if (window.VSSCanvas.tools && window.VSSCanvas.tools[window.VSSCanvas.currentTool]) {
                window.VSSCanvas.tools[window.VSSCanvas.currentTool].draw(currentX, currentY, pressure);
            } else {
                // Fallback to basic drawing
                if (window.VSSCanvas.currentTool === 'pen') {
                    window.VSSCanvas.ctx.globalCompositeOperation = 'source-over';
                    window.VSSCanvas.ctx.strokeStyle = window.VSSCanvas.settings.color;
                    window.VSSCanvas.ctx.lineWidth = window.VSSCanvas.settings.strokeSize;
                } else if (window.VSSCanvas.currentTool === 'eraser') {
                    window.VSSCanvas.ctx.globalCompositeOperation = 'destination-out';
                    window.VSSCanvas.ctx.lineWidth = window.VSSCanvas.settings.strokeSize * 2;
                }
                
                window.VSSCanvas.ctx.lineTo(currentX, currentY);
                window.VSSCanvas.ctx.stroke();
            }
            
            [window.VSSCanvas.lastX, window.VSSCanvas.lastY] = [currentX, currentY];
            
            // Send drawing data to extension (throttled)
            if (Math.random() < 0.1) { // Only send 10% of drawing events to avoid spam
                sendMessage({
                    command: 'drawing',
                    data: {
                        tool: window.VSSCanvas.currentTool,
                        x: currentX,
                        y: currentY,
                        lastX: window.VSSCanvas.lastX,
                        lastY: window.VSSCanvas.lastY
                    }
                });
            }
        }
        
        function stopDrawing() {
            if (!window.VSSCanvas.isDrawing) return;
            
            window.VSSCanvas.isDrawing = false;
            window.VSSCanvas.ctx.beginPath(); // Reset path
            
            sendMessage({
                command: 'drawingEnded',
                data: { tool: window.VSSCanvas.currentTool }
            });
        }
        
        function handleTouch(e) {
            e.preventDefault();
            
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                            e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            
            window.VSSCanvas.canvas.dispatchEvent(mouseEvent);
        }
        
        function getMousePos(e) {
            const rect = window.VSSCanvas.canvas.getBoundingClientRect();
            // No need to scale by DPR here since we're working in CSS pixels
            // The scaling is handled by the context.scale() in resizeCanvas
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }
        
        function clearCanvas() {
            window.VSSCanvas.ctx.clearRect(0, 0, window.VSSCanvas.canvas.width, window.VSSCanvas.canvas.height);
            updateStatus('Canvas cleared');
            
            sendMessage({
                command: 'canvasCleared',
                data: {}
            });
        }
        
        function updateStatus(message) {
            const statusElement = document.getElementById('status');
            const statusText = statusElement.querySelector('span:first-child');
            statusText.textContent = `VSS Drawing Canvas - ${message}`;
        }
        
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connection-status');
            statusElement.textContent = connected ? 'Connected' : 'Disconnected';
            statusElement.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
        }
        
        // Start connection monitoring after initialization
        function startConnectionMonitoring() {
            window.VSSCanvas.connectionCheckInterval = setInterval(function() {
                const timeSinceLastMessage = Date.now() - window.VSSCanvas.lastMessageTime;
                const isConnected = timeSinceLastMessage < 30000; // 30 seconds timeout
                updateConnectionStatus(isConnected);
            }, 5000);
        }

        // Listen for messages from extension to track connection
        window.addEventListener('message', function(event) {
            window.VSSCanvas.lastMessageTime = Date.now();
            updateConnectionStatus(true);
        });

        // Start monitoring once canvas is ready
        setTimeout(function() {
            if (window.VSSCanvas.hasInitialized) {
                startConnectionMonitoring();
            }
        }, 1000);

        // Cleanup on unload
        window.addEventListener('beforeunload', function() {
            if (window.VSSCanvas.connectionCheckInterval) {
                clearInterval(window.VSSCanvas.connectionCheckInterval);
            }
            if (window.VSSCanvas.initializationTimeout) {
                clearTimeout(window.VSSCanvas.initializationTimeout);
            }
        });
        
        // Add methods to the existing VSSCanvas namespace
        window.VSSCanvas.init = function() {
            console.log('VSSCanvas: Starting initialization for instance ID:', this.instanceId);
            
            if (this.initialized) {
                console.log('VSSCanvas: Already initialized, performing cleanup before reinitializing...');
                this.cleanup();
            }
            
            try {
                // Mark initialization start time for debugging
                this.initStartedAt = new Date().toISOString();
                
                updateLoadingStatus('Initializing canvas...');
                initializeCanvas();
                
                updateLoadingStatus('Setting up drawing tools...');
                setupEventListeners();
                
                updateLoadingStatus('Establishing connection...');
                setupMessagePassing();
                
                updateLoadingStatus('Canvas ready!');
                updateStatus('Canvas initialized successfully');
                
                // Mark as initialized
                this.initialized = true;
                this.initCompletedAt = new Date().toISOString();
                
                console.log('VSSCanvas: Initialization completed successfully for instance ID:', this.instanceId);
                
                // Hide loading screen after a short delay
                setTimeout(function() {
                    if (window.VSSCanvas.initializationTimeout) {
                        clearTimeout(window.VSSCanvas.initializationTimeout);
                        window.VSSCanvas.initializationTimeout = null;
                    }
                    hideLoadingScreen();
                }, 500);
                
                return true;
            } catch (error) {
                console.error('VSSCanvas: Initialization failed for instance ID:', this.instanceId, error);
                
                // Clear initialization timeout on error
                if (this.initializationTimeout) {
                    clearTimeout(this.initializationTimeout);
                    this.initializationTimeout = null;
                }
                
                // Mark initialization failure time for debugging
                this.initFailedAt = new Date().toISOString();
                this.lastInitError = error.message;
                
                showError('Initialization failed: ' + error.message, error.stack);
                return false;
            }
        };
        
        // Cleanup method with comprehensive existence checks
        window.VSSCanvas.cleanup = function() {
            console.log('VSSCanvas: Starting cleanup for instance ID:', this.instanceId);
            
            try {
                // Clear timeouts with existence checks
                if (this.initializationTimeout) {
                    console.log('VSSCanvas: Clearing initialization timeout');
                    clearTimeout(this.initializationTimeout);
                    this.initializationTimeout = null;
                }
                
                if (this.connectionCheckInterval) {
                    console.log('VSSCanvas: Clearing connection check interval');
                    clearInterval(this.connectionCheckInterval);
                    this.connectionCheckInterval = null;
                }
                
                // Clear canvas if it exists and is valid
                if (this.ctx && this.canvas) {
                    try {
                        console.log('VSSCanvas: Clearing canvas content');
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    } catch (canvasError) {
                        console.warn('VSSCanvas: Error clearing canvas:', canvasError);
                    }
                }
                
                // Reset state variables
                this.hasInitialized = false;
                this.isDrawing = false;
                this.currentTool = 'pen';
                this.lastX = 0;
                this.lastY = 0;
                
                // Reset DOM references
                this.loadingScreen = null;
                this.errorScreen = null;
                this.loadingStatus = null;
                
                // Reset canvas references
                this.canvas = null;
                this.ctx = null;
                
                // Reset initialization flag
                this.initialized = false;
                
                // Update timestamp for debugging
                this.lastCleanupAt = new Date().toISOString();
                
                console.log('VSSCanvas: Cleanup completed successfully for instance ID:', this.instanceId);
                
            } catch (cleanupError) {
                console.error('VSSCanvas: Error during cleanup:', cleanupError);
                // Continue with cleanup even if some parts fail
                this.initialized = false;
                this.hasInitialized = false;
            }
        };
        
        // Check if canvas is initialized
        window.VSSCanvas.isInitialized = function() {
            return this.initialized && this.hasInitialized;
        };
        
        // Get current canvas state
        window.VSSCanvas.getState = function() {
            return {
                initialized: this.initialized,
                hasInitialized: this.hasInitialized,
                isDrawing: this.isDrawing,
                currentTool: this.currentTool,
                canvasSize: this.canvas ? { width: this.canvas.width, height: this.canvas.height } : null
            };
        };
        
        // Force reinitialization
        window.VSSCanvas.reinitialize = function() {
            this.cleanup();
            return this.init();
        };
        
        })(); // End of IIFE
    </script>
</body>
</html>