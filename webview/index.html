<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; script-src 'unsafe-inline';">
    <title>VSS Drawing Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            color: #cccccc;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        #status {
            background: rgba(30, 30, 30, 0.9);
            color: #cccccc;
            padding: 8px 12px;
            font-size: 12px;
            border-bottom: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #drawing-canvas {
            flex: 1;
            background: white;
            cursor: crosshair;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .toolbar {
            position: absolute;
            top: 50px;
            left: 10px;
            background: rgba(30, 30, 30, 0.9);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .tool-button {
            background: #3c3c3c;
            border: none;
            color: #cccccc;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .tool-button:hover {
            background: #4c4c4c;
        }
        
        .tool-button.active {
            background: #007acc;
        }
        
        .connection-status {
            font-size: 11px;
            color: #999;
        }
        
        .connection-status.connected {
            color: #28a745;
        }
        
        .connection-status.disconnected {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="status">
            <span>VSS Drawing Canvas - Ready</span>
            <span class="connection-status disconnected" id="connection-status">Disconnected</span>
        </div>
        
        <div class="toolbar">
            <button class="tool-button active" data-tool="pen" id="pen-tool">Pen</button>
            <button class="tool-button" data-tool="eraser" id="eraser-tool">Eraser</button>
            <button class="tool-button" id="clear-canvas">Clear</button>
        </div>
        
        <canvas id="drawing-canvas"></canvas>
    </div>

    <script>
        // Canvas and drawing state
        let canvas, ctx;
        let isDrawing = false;
        let currentTool = 'pen';
        let lastX = 0;
        let lastY = 0;
        
        // VS Code API for message passing
        const vscode = acquireVsCodeApi();
        
        // Initialize canvas when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeCanvas();
            setupEventListeners();
            setupMessagePassing();
            updateStatus('Canvas initialized successfully');
        });
        
        function initializeCanvas() {
            try {
                canvas = document.getElementById('drawing-canvas');
                ctx = canvas.getContext('2d');
                
                // Set canvas size to fill container
                resizeCanvas();
                
                // Set default drawing properties
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                
                updateStatus('Canvas ready for drawing');
            } catch (error) {
                updateStatus('Error initializing canvas: ' + error.message);
                console.error('Canvas initialization error:', error);
            }
        }
        
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const statusHeight = document.getElementById('status').offsetHeight;
            
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight - statusHeight;
        }
        
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Tool buttons
            document.querySelectorAll('.tool-button[data-tool]').forEach(button => {
                button.addEventListener('click', function() {
                    selectTool(this.dataset.tool);
                });
            });
            
            // Clear canvas button
            document.getElementById('clear-canvas').addEventListener('click', clearCanvas);
            
            // Mouse events for drawing
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Touch events for mobile/tablet support
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);
        }
        
        function setupMessagePassing() {
            // Listen for messages from VS Code extension
            window.addEventListener('message', event => {
                const message = event.data;
                
                switch (message.command) {
                    case 'clearCanvas':
                        clearCanvas();
                        break;
                    case 'setTool':
                        selectTool(message.tool);
                        break;
                    case 'connectionStatus':
                        updateConnectionStatus(message.connected);
                        break;
                    default:
                        console.log('Unknown message:', message);
                }
            });
            
            // Send initial ready message to extension
            sendMessage({
                command: 'canvasReady',
                data: {
                    width: canvas.width,
                    height: canvas.height
                }
            });
        }
        
        function sendMessage(message) {
            try {
                vscode.postMessage(message);
            } catch (error) {
                console.error('Error sending message to extension:', error);
                updateStatus('Communication error with extension');
            }
        }
        
        function selectTool(tool) {
            currentTool = tool;
            
            // Update button states
            document.querySelectorAll('.tool-button[data-tool]').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            // Update cursor
            canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
            
            updateStatus(`Selected tool: ${tool}`);
            
            // Notify extension of tool change
            sendMessage({
                command: 'toolChanged',
                data: { tool: tool }
            });
        }
        
        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = getMousePos(e);
            
            // Start new path
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            
            sendMessage({
                command: 'drawingStarted',
                data: { 
                    tool: currentTool,
                    x: lastX, 
                    y: lastY 
                }
            });
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const [currentX, currentY] = getMousePos(e);
            
            if (currentTool === 'pen') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 10;
            }
            
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            
            [lastX, lastY] = [currentX, currentY];
            
            // Send drawing data to extension (throttled)
            if (Math.random() < 0.1) { // Only send 10% of drawing events to avoid spam
                sendMessage({
                    command: 'drawing',
                    data: {
                        tool: currentTool,
                        x: currentX,
                        y: currentY,
                        lastX: lastX,
                        lastY: lastY
                    }
                });
            }
        }
        
        function stopDrawing() {
            if (!isDrawing) return;
            
            isDrawing = false;
            ctx.beginPath(); // Reset path
            
            sendMessage({
                command: 'drawingEnded',
                data: { tool: currentTool }
            });
        }
        
        function handleTouch(e) {
            e.preventDefault();
            
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                            e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            
            canvas.dispatchEvent(mouseEvent);
        }
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateStatus('Canvas cleared');
            
            sendMessage({
                command: 'canvasCleared',
                data: {}
            });
        }
        
        function updateStatus(message) {
            const statusElement = document.getElementById('status');
            const statusText = statusElement.querySelector('span:first-child');
            statusText.textContent = `VSS Drawing Canvas - ${message}`;
        }
        
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connection-status');
            statusElement.textContent = connected ? 'Connected' : 'Disconnected';
            statusElement.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
        }
        
        // Error handling
        window.addEventListener('error', function(e) {
            updateStatus('Error: ' + e.message);
            sendMessage({
                command: 'error',
                data: {
                    message: e.message,
                    filename: e.filename,
                    lineno: e.lineno
                }
            });
        });
        
        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', function(e) {
            updateStatus('Promise error: ' + e.reason);
            sendMessage({
                command: 'error',
                data: {
                    message: 'Unhandled promise rejection: ' + e.reason
                }
            });
        });
    </script>
</body>
</html>