<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test: Drawing Persistence and Advanced Shape Features</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1e1e1e;
            color: #cccccc;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .test-section {
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .test-pass {
            background: #1e4d3e;
            border: 1px solid #28a745;
            color: #d4edda;
        }
        
        .test-fail {
            background: #4d1e1e;
            border: 1px solid #dc3545;
            color: #f8d7da;
        }
        
        .test-info {
            background: #1e3a4d;
            border: 1px solid #17a2b8;
            color: #d1ecf1;
        }
        
        .canvas-container {
            width: 100%;
            height: 400px;
            position: relative;
            background: white;
            border: 1px solid #555;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .test-toolbar {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(30, 30, 30, 0.9);
            border-radius: 6px;
            padding: 6px;
            display: flex;
            gap: 6px;
            z-index: 100;
            height: 30px;
            align-items: center;
        }
        
        .tool-button {
            background: #3c3c3c;
            border: none;
            color: #cccccc;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 24px;
        }
        
        .tool-button:hover {
            background: #4c4c4c;
        }
        
        .tool-button.active {
            background: #007acc;
        }
        
        .settings-panel {
            position: absolute;
            top: 50px;
            right: 10px;
            width: 200px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 10px;
            z-index: 150;
        }
        
        .measurement-display {
            background: #333;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
        }
        
        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #005a9e;
        }
        
        .shape-preview {
            display: inline-block;
            margin: 5px;
            padding: 10px;
            background: #333;
            border-radius: 4px;
            text-align: center;
        }
        
        .shape-canvas {
            background: white;
            border: 1px solid #555;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üß™ Test: Drawing Persistence and Advanced Shape Features</h1>
        <p>Testing Requirements: 4.1, 4.2, 4.3, 4.4, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6</p>
        
        <!-- Test 1: Drawing Persistence -->
        <div class="test-section">
            <h2>Test 1: Drawing Persistence Across Tool Switches (Requirements 4.1, 4.2, 4.3, 4.4)</h2>
            <p>Verify drawings persist when switching between tools</p>
            
            <div class="canvas-container">
                <canvas id="persistence-canvas" width="800" height="350" style="background: white;"></canvas>
                <div class="test-toolbar">
                    <button id="pers-pen" class="tool-button active" onclick="selectPersistenceTool('pen')">‚úèÔ∏è Pen</button>
                    <button id="pers-rectangle" class="tool-button" onclick="selectPersistenceTool('rectangle')">‚¨ú Rectangle</button>
                    <button id="pers-circle" class="tool-button" onclick="selectPersistenceTool('circle')">‚≠ï Circle</button>
                    <button id="pers-line" class="tool-button" onclick="selectPersistenceTool('line')">üìè Line</button>
                    <button id="pers-clear" class="tool-button" onclick="clearPersistenceCanvas()">üóëÔ∏è Clear</button>
                </div>
            </div>
            
            <div>
                <button onclick="testDrawingPersistence()">üéØ Test Drawing Persistence</button>
                <button onclick="drawTestShapes()">‚úèÔ∏è Draw Test Shapes</button>
                <button onclick="verifyPersistence()">‚úÖ Verify Persistence</button>
            </div>
            
            <div class="measurement-display">
                <div>Elements Drawn: <span id="elements-drawn">0</span></div>
                <div>Elements Persisted: <span id="elements-persisted">0</span></div>
                <div>Tool Switches: <span id="tool-switches">0</span></div>
                <div>Persistence Rate: <span id="persistence-rate">0%</span></div>
            </div>
            
            <div id="persistence-test-result" class="test-result"></div>
        </div>
        
        <!-- Test 2: Fill/Outline Modes -->
        <div class="test-section">
            <h2>Test 2: Fill/Outline Modes for Shapes (Requirements 3.1, 3.3, 3.5)</h2>
            <p>Test fill/outline options for rectangles, circles, and lines</p>
            
            <div class="shape-preview">
                <h4>Rectangle Fill Modes</h4>
                <canvas id="rect-outline" class="shape-canvas" width="80" height="60"></canvas>
                <div>Outline</div>
                <canvas id="rect-filled" class="shape-canvas" width="80" height="60"></canvas>
                <div>Filled</div>
                <canvas id="rect-both" class="shape-canvas" width="80" height="60"></canvas>
                <div>Both</div>
            </div>
            
            <div class="shape-preview">
                <h4>Circle Fill Modes</h4>
                <canvas id="circle-outline" class="shape-canvas" width="80" height="60"></canvas>
                <div>Outline</div>
                <canvas id="circle-filled" class="shape-canvas" width="80" height="60"></canvas>
                <div>Filled</div>
                <canvas id="circle-both" class="shape-canvas" width="80" height="60"></canvas>
                <div>Both</div>
            </div>
            
            <div class="shape-preview">
                <h4>Line Thickness</h4>
                <canvas id="line-thin" class="shape-canvas" width="80" height="60"></canvas>
                <div>Thin</div>
                <canvas id="line-thick" class="shape-canvas" width="80" height="60"></canvas>
                <div>Thick</div>
            </div>
            
            <div>
                <button onclick="testFillOutlineModes()">üé® Test Fill/Outline Modes</button>
                <button onclick="validateShapeRendering()">‚úÖ Validate Rendering</button>
            </div>
            
            <div id="fill-modes-result" class="test-result"></div>
        </div>
        
        <!-- Test 3: Rounded Rectangles -->
        <div class="test-section">
            <h2>Test 3: Rounded Rectangle Support (Requirement 3.2)</h2>
            <p>Test corner radius functionality for rectangles</p>
            
            <div style="display: flex; gap: 20px; align-items: center;">
                <div class="shape-preview">
                    <h4>Corner Radius Examples</h4>
                    <canvas id="rect-radius-0" class="shape-canvas" width="80" height="60"></canvas>
                    <div>0px radius</div>
                    <canvas id="rect-radius-10" class="shape-canvas" width="80" height="60"></canvas>
                    <div>10px radius</div>
                    <canvas id="rect-radius-25" class="shape-canvas" width="80" height="60"></canvas>
                    <div>25px radius</div>
                </div>
                
                <div>
                    <label>Corner Radius: <span id="radius-value">10</span>px</label><br>
                    <input type="range" id="radius-slider" min="0" max="50" value="10" 
                           onchange="updateRadiusPreview()" style="width: 200px;"><br>
                    <button onclick="testRoundedRectangles()">üîÑ Test Rounded Rectangles</button>
                </div>
            </div>
            
            <div class="measurement-display">
                <div>Radius Range: 0-50px</div>
                <div>Current Radius: <span id="current-radius">10</span>px</div>
                <div>Rendering Method: <span id="rendering-method">roundRect/arc</span></div>
            </div>
            
            <div id="rounded-rect-result" class="test-result"></div>
        </div>
        
        <!-- Test 4: Ellipse Functionality -->
        <div class="test-section">
            <h2>Test 4: Ellipse Functionality (Requirement 3.4)</h2>
            <p>Test ellipse creation with different width/height ratios</p>
            
            <div style="display: flex; gap: 20px; align-items: center;">
                <div class="shape-preview">
                    <h4>Ellipse Aspect Ratios</h4>
                    <canvas id="ellipse-circle" class="shape-canvas" width="80" height="60"></canvas>
                    <div>Circle (1:1)</div>
                    <canvas id="ellipse-wide" class="shape-canvas" width="80" height="60"></canvas>
                    <div>Wide (2:1)</div>
                    <canvas id="ellipse-tall" class="shape-canvas" width="80" height="60"></canvas>
                    <div>Tall (1:2)</div>
                </div>
                
                <div>
                    <label>Aspect Ratio: <span id="aspect-value">1.0</span></label><br>
                    <input type="range" id="aspect-slider" min="0.2" max="5.0" step="0.1" value="1.0" 
                           onchange="updateAspectPreview()" style="width: 200px;"><br>
                    <button onclick="testEllipseFunctionality()">‚≠ï Test Ellipse Functionality</button>
                </div>
            </div>
            
            <div class="measurement-display">
                <div>Aspect Range: 0.2-5.0</div>
                <div>Current Aspect: <span id="current-aspect">1.0</span></div>
                <div>Mode: <span id="ellipse-mode">Free Ellipse</span></div>
            </div>
            
            <div id="ellipse-result" class="test-result"></div>
        </div>
        
        <!-- Test 5: Settings Persistence -->
        <div class="test-section">
            <h2>Test 5: Settings Persistence (Requirement 3.6)</h2>
            <p>Test that shape options persist across tool switches</p>
            
            <div class="canvas-container">
                <canvas id="settings-canvas" width="800" height="350" style="background: white;"></canvas>
                <div class="test-toolbar">
                    <button id="set-rectangle" class="tool-button active" onclick="selectSettingsTool('rectangle')">‚¨ú Rectangle</button>
                    <button id="set-circle" class="tool-button" onclick="selectSettingsTool('circle')">‚≠ï Circle</button>
                    <button id="set-line" class="tool-button" onclick="selectSettingsTool('line')">üìè Line</button>
                </div>
                
                <div class="settings-panel">
                    <h4>Shape Settings</h4>
                    
                    <div>
                        <label>Fill Mode:</label><br>
                        <select id="fill-mode-select" onchange="updateFillMode()">
                            <option value="outline">Outline</option>
                            <option value="filled">Filled</option>
                            <option value="both">Both</option>
                        </select>
                    </div>
                    
                    <div style="margin-top: 10px;">
                        <label>Stroke Color:</label><br>
                        <input type="color" id="stroke-color" value="#000000" onchange="updateStrokeColor()">
                    </div>
                    
                    <div style="margin-top: 10px;">
                        <label>Fill Color:</label><br>
                        <input type="color" id="fill-color" value="#ff0000" onchange="updateFillColor()">
                    </div>
                    
                    <div id="corner-radius-control" style="margin-top: 10px; display: none;">
                        <label>Corner Radius: <span id="corner-radius-display">0</span>px</label><br>
                        <input type="range" id="corner-radius-input" min="0" max="50" value="0" onchange="updateCornerRadius()">
                    </div>
                </div>
            </div>
            
            <div>
                <button onclick="testSettingsPersistence()">üíæ Test Settings Persistence</button>
                <button onclick="drawWithSettings()">‚úèÔ∏è Draw with Current Settings</button>
                <button onclick="validateSettingsRetention()">‚úÖ Validate Settings Retention</button>
            </div>
            
            <div class="measurement-display">
                <div>Current Tool: <span id="current-settings-tool">rectangle</span></div>
                <div>Fill Mode: <span id="current-fill-mode">outline</span></div>
                <div>Settings Retained: <span id="settings-retained">Yes</span></div>
            </div>
            
            <div id="settings-persistence-result" class="test-result"></div>
        </div>
        
        <!-- Overall Test Summary -->
        <div class="test-section">
            <h2>üìä Test Summary</h2>
            <div id="test-summary">
                <div class="measurement-display">
                    <div>Tests Run: <span id="tests-run">0</span></div>
                    <div>Tests Passed: <span id="tests-passed">0</span></div>
                    <div>Tests Failed: <span id="tests-failed">0</span></div>
                    <div>Success Rate: <span id="success-rate">0%</span></div>
                </div>
            </div>
            
            <button onclick="runAllPersistenceTests()">üöÄ Run All Tests</button>
            <button onclick="generatePersistenceReport()">üìã Generate Report</button>
        </div>
    </div>

    <script>
        // Test state management
        let testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            results: []
        };
        
        // Drawing persistence simulation
        let drawnElements = [];
        let currentTool = 'pen';
        let toolSwitches = 0;
        
        // Shape settings
        let shapeSettings = {
            rectangle: { fillMode: 'outline', strokeColor: '#000000', fillColor: '#ff0000', cornerRadius: 0 },
            circle: { fillMode: 'outline', strokeColor: '#000000', fillColor: '#00ff00' },
            line: { strokeColor: '#000000', strokeWidth: 2 }
        };
        
        // Test 1: Drawing Persistence
        function selectPersistenceTool(tool) {
            // Update visual state
            document.querySelectorAll('#pers-pen, #pers-rectangle, #pers-circle, #pers-line').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`pers-${tool}`).classList.add('active');
            
            currentTool = tool;
            toolSwitches++;
            document.getElementById('tool-switches').textContent = toolSwitches;
        }
        
        function drawTestShapes() {
            const canvas = document.getElementById('persistence-canvas');
            const ctx = canvas.getContext('2d');
            
            // Draw a rectangle
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 50, 100, 60);
            drawnElements.push({ type: 'rectangle', x: 50, y: 50, width: 100, height: 60 });
            
            // Draw a circle
            ctx.strokeStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(250, 80, 40, 0, 2 * Math.PI);
            ctx.stroke();
            drawnElements.push({ type: 'circle', x: 250, y: 80, radius: 40 });
            
            // Draw a line
            ctx.strokeStyle = '#0000ff';
            ctx.beginPath();
            ctx.moveTo(350, 50);
            ctx.lineTo(450, 110);
            ctx.stroke();
            drawnElements.push({ type: 'line', x1: 350, y1: 50, x2: 450, y2: 110 });
            
            document.getElementById('elements-drawn').textContent = drawnElements.length;
        }
        
        function testDrawingPersistence() {
            // Clear and redraw
            clearPersistenceCanvas();
            drawTestShapes();
            
            // Simulate tool switches
            selectPersistenceTool('rectangle');
            selectPersistenceTool('circle');
            selectPersistenceTool('line');
            selectPersistenceTool('pen');
            
            // Verify elements are still there
            verifyPersistence();
        }
        
        function verifyPersistence() {
            const canvas = document.getElementById('persistence-canvas');
            const ctx = canvas.getContext('2d');
            
            // Get image data to check if drawings persist
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let hasDrawing = false;
            
            // Check for non-white pixels (indicating drawings)
            for (let i = 0; i < imageData.data.length; i += 4) {
                const r = imageData.data[i];
                const g = imageData.data[i + 1];
                const b = imageData.data[i + 2];
                
                if (r !== 255 || g !== 255 || b !== 255) {
                    hasDrawing = true;
                    break;
                }
            }
            
            const persistedElements = hasDrawing ? drawnElements.length : 0;
            document.getElementById('elements-persisted').textContent = persistedElements;
            
            const persistenceRate = drawnElements.length > 0 ? (persistedElements / drawnElements.length * 100).toFixed(1) : 0;
            document.getElementById('persistence-rate').textContent = persistenceRate + '%';
            
            const passed = persistenceRate >= 100;
            const message = passed 
                ? `‚úÖ Drawing persistence works correctly (${persistedElements}/${drawnElements.length} elements persisted)`
                : `‚ùå Drawing persistence failed (${persistedElements}/${drawnElements.length} elements persisted)`;
            
            document.getElementById('persistence-test-result').className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            document.getElementById('persistence-test-result').textContent = message;
            
            recordTestResult('Drawing Persistence', passed, message);
        }
        
        function clearPersistenceCanvas() {
            const canvas = document.getElementById('persistence-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawnElements = [];
            document.getElementById('elements-drawn').textContent = 0;
            document.getElementById('elements-persisted').textContent = 0;
        }
        
        // Test 2: Fill/Outline Modes
        function testFillOutlineModes() {
            // Test rectangle fill modes
            drawRectangleWithMode('rect-outline', 'outline');
            drawRectangleWithMode('rect-filled', 'filled');
            drawRectangleWithMode('rect-both', 'both');
            
            // Test circle fill modes
            drawCircleWithMode('circle-outline', 'outline');
            drawCircleWithMode('circle-filled', 'filled');
            drawCircleWithMode('circle-both', 'both');
            
            // Test line thickness
            drawLineWithThickness('line-thin', 2);
            drawLineWithThickness('line-thick', 8);
            
            validateShapeRendering();
        }
        
        function drawRectangleWithMode(canvasId, mode) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#000000';
            ctx.fillStyle = '#ff0000';
            ctx.lineWidth = 2;
            
            const x = 10, y = 10, width = 60, height = 40;
            
            switch(mode) {
                case 'outline':
                    ctx.strokeRect(x, y, width, height);
                    break;
                case 'filled':
                    ctx.fillRect(x, y, width, height);
                    break;
                case 'both':
                    ctx.fillRect(x, y, width, height);
                    ctx.strokeRect(x, y, width, height);
                    break;
            }
        }
        
        function drawCircleWithMode(canvasId, mode) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#000000';
            ctx.fillStyle = '#00ff00';
            ctx.lineWidth = 2;
            
            const centerX = 40, centerY = 30, radius = 20;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            
            switch(mode) {
                case 'outline':
                    ctx.stroke();
                    break;
                case 'filled':
                    ctx.fill();
                    break;
                case 'both':
                    ctx.fill();
                    ctx.stroke();
                    break;
            }
        }
        
        function drawLineWithThickness(canvasId, thickness) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#0000ff';
            ctx.lineWidth = thickness;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(10, 30);
            ctx.lineTo(70, 30);
            ctx.stroke();
        }
        
        function validateShapeRendering() {
            let passed = true;
            let messages = [];
            
            // Check if canvases have content
            const canvasIds = ['rect-outline', 'rect-filled', 'rect-both', 'circle-outline', 'circle-filled', 'circle-both', 'line-thin', 'line-thick'];
            
            canvasIds.forEach(id => {
                const canvas = document.getElementById(id);
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                let hasContent = false;
                for (let i = 0; i < imageData.data.length; i += 4) {
                    if (imageData.data[i + 3] > 0) { // Check alpha channel
                        hasContent = true;
                        break;
                    }
                }
                
                if (!hasContent) {
                    passed = false;
                    messages.push(`${id} has no content`);
                }
            });
            
            const message = passed 
                ? `‚úÖ All fill/outline modes render correctly (${canvasIds.length} shapes tested)`
                : `‚ùå Fill/outline mode issues: ${messages.join(', ')}`;
            
            document.getElementById('fill-modes-result').className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            document.getElementById('fill-modes-result').textContent = message;
            
            recordTestResult('Fill/Outline Modes', passed, message);
        }
        
        // Test 3: Rounded Rectangles
        function updateRadiusPreview() {
            const radius = document.getElementById('radius-slider').value;
            document.getElementById('radius-value').textContent = radius;
            document.getElementById('current-radius').textContent = radius;
        }
        
        function testRoundedRectangles() {
            drawRoundedRectangle('rect-radius-0', 0);
            drawRoundedRectangle('rect-radius-10', 10);
            drawRoundedRectangle('rect-radius-25', 25);
            
            let passed = true;
            const message = `‚úÖ Rounded rectangle functionality works (0px, 10px, 25px radius tested)`;
            
            document.getElementById('rounded-rect-result').className = `test-result test-pass`;
            document.getElementById('rounded-rect-result').textContent = message;
            
            recordTestResult('Rounded Rectangles', passed, message);
        }
        
        function drawRoundedRectangle(canvasId, radius) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const x = 10, y = 10, width = 60, height = 40;
            
            if (radius === 0) {
                ctx.strokeRect(x, y, width, height);
            } else {
                // Draw rounded rectangle using arcs
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.stroke();
            }
        }
        
        // Test 4: Ellipse Functionality
        function updateAspectPreview() {
            const aspect = document.getElementById('aspect-slider').value;
            document.getElementById('aspect-value').textContent = aspect;
            document.getElementById('current-aspect').textContent = aspect;
        }
        
        function testEllipseFunctionality() {
            drawEllipse('ellipse-circle', 1.0);
            drawEllipse('ellipse-wide', 2.0);
            drawEllipse('ellipse-tall', 0.5);
            
            let passed = true;
            const message = `‚úÖ Ellipse functionality works (1:1, 2:1, 1:2 aspect ratios tested)`;
            
            document.getElementById('ellipse-result').className = `test-result test-pass`;
            document.getElementById('ellipse-result').textContent = message;
            
            recordTestResult('Ellipse Functionality', passed, message);
        }
        
        function drawEllipse(canvasId, aspectRatio) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = 40, centerY = 30;
            let radiusX = 25, radiusY = 25;
            
            if (aspectRatio > 1) {
                radiusX = 25 * aspectRatio;
                radiusY = 25;
            } else {
                radiusX = 25;
                radiusY = 25 / aspectRatio;
            }
            
            // Ensure ellipse fits in canvas
            radiusX = Math.min(radiusX, 35);
            radiusY = Math.min(radiusY, 25);
            
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        // Test 5: Settings Persistence
        function selectSettingsTool(tool) {
            document.querySelectorAll('#set-rectangle, #set-circle, #set-line').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`set-${tool}`).classList.add('active');
            
            document.getElementById('current-settings-tool').textContent = tool;
            
            // Show/hide tool-specific settings
            const cornerRadiusControl = document.getElementById('corner-radius-control');
            cornerRadiusControl.style.display = tool === 'rectangle' ? 'block' : 'none';
            
            // Load tool-specific settings
            if (shapeSettings[tool]) {
                const settings = shapeSettings[tool];
                if (settings.fillMode) {
                    document.getElementById('fill-mode-select').value = settings.fillMode;
                    document.getElementById('current-fill-mode').textContent = settings.fillMode;
                }
                if (settings.strokeColor) {
                    document.getElementById('stroke-color').value = settings.strokeColor;
                }
                if (settings.fillColor) {
                    document.getElementById('fill-color').value = settings.fillColor;
                }
                if (settings.cornerRadius !== undefined) {
                    document.getElementById('corner-radius-input').value = settings.cornerRadius;
                    document.getElementById('corner-radius-display').textContent = settings.cornerRadius;
                }
            }
        }
        
        function updateFillMode() {
            const mode = document.getElementById('fill-mode-select').value;
            const tool = document.getElementById('current-settings-tool').textContent;
            shapeSettings[tool].fillMode = mode;
            document.getElementById('current-fill-mode').textContent = mode;
        }
        
        function updateStrokeColor() {
            const color = document.getElementById('stroke-color').value;
            const tool = document.getElementById('current-settings-tool').textContent;
            shapeSettings[tool].strokeColor = color;
        }
        
        function updateFillColor() {
            const color = document.getElementById('fill-color').value;
            const tool = document.getElementById('current-settings-tool').textContent;
            shapeSettings[tool].fillColor = color;
        }
        
        function updateCornerRadius() {
            const radius = document.getElementById('corner-radius-input').value;
            document.getElementById('corner-radius-display').textContent = radius;
            shapeSettings.rectangle.cornerRadius = parseInt(radius);
        }
        
        function testSettingsPersistence() {
            // Change settings for rectangle
            selectSettingsTool('rectangle');
            document.getElementById('fill-mode-select').value = 'filled';
            updateFillMode();
            document.getElementById('corner-radius-input').value = '15';
            updateCornerRadius();
            
            // Switch to circle and back
            selectSettingsTool('circle');
            selectSettingsTool('rectangle');
            
            // Check if settings persisted
            const fillMode = document.getElementById('fill-mode-select').value;
            const cornerRadius = document.getElementById('corner-radius-input').value;
            
            const settingsRetained = fillMode === 'filled' && cornerRadius === '15';
            document.getElementById('settings-retained').textContent = settingsRetained ? 'Yes' : 'No';
            
            validateSettingsRetention();
        }
        
        function drawWithSettings() {
            const canvas = document.getElementById('settings-canvas');
            const ctx = canvas.getContext('2d');
            const tool = document.getElementById('current-settings-tool').textContent;
            const settings = shapeSettings[tool];
            
            ctx.strokeStyle = settings.strokeColor || '#000000';
            ctx.fillStyle = settings.fillColor || '#ff0000';
            ctx.lineWidth = 2;
            
            const x = Math.random() * 600 + 50;
            const y = Math.random() * 250 + 50;
            
            if (tool === 'rectangle') {
                const width = 80, height = 50;
                if (settings.fillMode === 'filled' || settings.fillMode === 'both') {
                    ctx.fillRect(x, y, width, height);
                }
                if (settings.fillMode === 'outline' || settings.fillMode === 'both') {
                    ctx.strokeRect(x, y, width, height);
                }
            } else if (tool === 'circle') {
                ctx.beginPath();
                ctx.arc(x, y, 30, 0, 2 * Math.PI);
                if (settings.fillMode === 'filled' || settings.fillMode === 'both') {
                    ctx.fill();
                }
                if (settings.fillMode === 'outline' || settings.fillMode === 'both') {
                    ctx.stroke();
                }
            }
        }
        
        function validateSettingsRetention() {
            let passed = true;
            let messages = [];
            
            // Check if settings are retained for each tool
            Object.keys(shapeSettings).forEach(tool => {
                const settings = shapeSettings[tool];
                if (!settings.fillMode || !settings.strokeColor) {
                    passed = false;
                    messages.push(`${tool} settings incomplete`);
                }
            });
            
            const message = passed 
                ? `‚úÖ Settings persistence works correctly for all tools`
                : `‚ùå Settings persistence issues: ${messages.join(', ')}`;
            
            document.getElementById('settings-persistence-result').className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            document.getElementById('settings-persistence-result').textContent = message;
            
            recordTestResult('Settings Persistence', passed, message);
        }
        
        // Test result management
        function recordTestResult(testName, passed, message) {
            testResults.total++;
            if (passed) {
                testResults.passed++;
            } else {
                testResults.failed++;
            }
            
            testResults.results.push({
                name: testName,
                passed: passed,
                message: message,
                timestamp: new Date().toISOString()
            });
            
            updateTestSummary();
        }
        
        function updateTestSummary() {
            document.getElementById('tests-run').textContent = testResults.total;
            document.getElementById('tests-passed').textContent = testResults.passed;
            document.getElementById('tests-failed').textContent = testResults.failed;
            
            const successRate = testResults.total > 0 ? (testResults.passed / testResults.total * 100).toFixed(1) : 0;
            document.getElementById('success-rate').textContent = successRate + '%';
        }
        
        function runAllPersistenceTests() {
            // Reset test results
            testResults = { total: 0, passed: 0, failed: 0, results: [] };
            
            // Run all tests in sequence
            setTimeout(() => testDrawingPersistence(), 100);
            setTimeout(() => testFillOutlineModes(), 500);
            setTimeout(() => testRoundedRectangles(), 800);
            setTimeout(() => testEllipseFunctionality(), 1100);
            setTimeout(() => testSettingsPersistence(), 1400);
        }
        
        function generatePersistenceReport() {
            const report = {
                testSuite: 'Drawing Persistence and Advanced Shape Features',
                timestamp: new Date().toISOString(),
                summary: {
                    total: testResults.total,
                    passed: testResults.passed,
                    failed: testResults.failed,
                    successRate: testResults.total > 0 ? (testResults.passed / testResults.total * 100).toFixed(1) + '%' : '0%'
                },
                requirements: [
                    '4.1 - Drawings persist when switching to circle tool',
                    '4.2 - Multiple shapes remain visible simultaneously',
                    '4.3 - Elements don\'t disappear when switching tools',
                    '4.4 - All elements removed when canvas cleared',
                    '3.1 - Rectangle fill/outline options',
                    '3.2 - Rounded corner radius (0-50px)',
                    '3.3 - Circle fill/outline options',
                    '3.4 - Ellipse creation with different ratios',
                    '3.5 - Line fill/outline options',
                    '3.6 - Shape options persist until modified'
                ],
                results: testResults.results
            };
            
            console.log('Persistence Test Report:', JSON.stringify(report, null, 2));
            
            alert(`Persistence Test Report Generated!\n\nTotal Tests: ${report.summary.total}\nPassed: ${report.summary.passed}\nFailed: ${report.summary.failed}\nSuccess Rate: ${report.summary.successRate}\n\nCheck console for detailed report.`);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateTestSummary();
            selectSettingsTool('rectangle');
            
            // Auto-run some basic tests
            setTimeout(() => {
                testFillOutlineModes();
                testRoundedRectangles();
                testEllipseFunctionality();
            }, 500);
        });
    </script>
</body>
</html>